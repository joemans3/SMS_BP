{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Single Molecule Simulations - BP (SMS_BP) # Author and affiliation: # Baljyot Singh Parmar baljyot.parmar@mail.mcgill.ca Affiliation at the time of writing: McGill University, Canada. Weber Lab Date last modified: 2024-09-27 # This is a short doc for the Track Simulations along with cluster simulations. # Author: Baljyot Singh Parmar Affiliation at the time of writing: McGill University, Canada. Weber Lab 1. Installation # Please note, all these are for macOS/linux. I need to test on windows (I don't remember the commands, but will set up a VM to test this). But these commands should have windows equivalents. If you run into any issues please create a Github issue on the repository as it will help me manage different issues with different people and also create a resource for people encountering a solved issue. # Anaconda # Make sure you have anaconda installed: https://www.anaconda.com/download Download or clone this repository. In the conda prompt, navigate to the folder where you downloaded this repository using : cd \"path_to_folder\" Using the SMS_BP.yml file, create a new environment using: conda env create -f SMS_BP.yml If you get an environment resolve error but you have anaconda installed just skip to step 6. The .yml file is for people who are using miniconda and might not have the packages already installed with the full anaconda install. You may want to still have a conda environment so just create a generic one if you want with the name SMS_BP or whatever you want with python>=3.10. Explicitly, conda create -n [my_env_name] python=3.10.13 Activate the environment using: conda activate SMS_BP Now we will install this package in edit mode. Run the command: pip install -e . --config-settings editable_mode=compat Pip # Make sure you have pip installed: https://pip.pypa.io/en/stable/installing/ Make sure you have python 3.10.13 as the active interpreter (through venv or conda or whatever you want). Make sure pip is also installed. Install from pypi using: pip install SMS-BP Installing the CLI tool using UV # Install UV (https://docs.astral.sh/uv/getting-started/installation/). Run the command: uv tool install SMS_BP You will have access to two CLI commands (using the uv interface): run_SMS_BP runsim : This is the main entry point for the simulation. (see run_SMS_BP runsim --help for more details) run_SMS_BP config : This is a helper tool to generate a template config file for the simulation. (see run_SMS_BP config --help for more details) Note: using run_SMS_BP --help will show you all the available commands. You can now use these tools (they are isolated in their own env created by uv, which is cool): run_SMS_BP config [PATH_TO_CONFIG_FILE] run_SMS_BP runsim [PATH_TO_SAVED_CONFIG_FILE] 2. Running the Simulation # Having installed the package, make sure the CLI commands are working: run_SMS_BP --help If this does not work submit an issue on the github repository. TODO: convert this into tests. This is a note on using the CLI tool properly. In the install (step 6) we also installed a CLI tool to interface with the program from anywhere. The only condition is that you are in the SMS_BP conda environment or similar venv you created and installed to (unless you used uv). Create a template of the config file with default parameters using bash run_SMS_BP config [PATH_TO_CONFIG_FILE] This will create a sim_config.json file in the current directory. You can add a optional argument (path) to be a [PATH] to save the file elsewhere. To run the CLI tool after the install we can type bash run_SMS_BP runsim [PATH_TO_SAVED_CONFIG_FILE] If you used 1) then this is just: bash run_SMS_BP runsim sim_config.json from anywhere assuming the path you provide is absolute. In the background all this is doing is running: python from SMS_BP.run_cell_simulation import typer_app_sms_bp; typer_app_sms_bp() This is the entry point. Do note that the config checker is not robust so if you have prodived the wrong types or excluded some parameters which are required alongside other ones you will get an error. Read the src/SMS_BP/sim_config.md for details into the config file parameters. TODO: create CI tests for this. If you run into any issues please create a Github issue on the repository as it will help me manage different issues with different people and also create a resource for people encountering a solved issue.","title":"Hello and Install"},{"location":"#single_molecule_simulations_-_bp_sms_bp","text":"","title":"Single Molecule Simulations - BP (SMS_BP)"},{"location":"#author_and_affiliation","text":"Baljyot Singh Parmar baljyot.parmar@mail.mcgill.ca Affiliation at the time of writing: McGill University, Canada. Weber Lab","title":"Author and affiliation:"},{"location":"#date_last_modified_2024-09-27","text":"","title":"Date last modified: 2024-09-27"},{"location":"#this_is_a_short_doc_for_the_track_simulations_along_with_cluster_simulations","text":"Author: Baljyot Singh Parmar Affiliation at the time of writing: McGill University, Canada. Weber Lab","title":"This is a short doc for the Track Simulations along with cluster simulations."},{"location":"#1_installation","text":"","title":"1. Installation"},{"location":"#please_note_all_these_are_for_macoslinux_i_need_to_test_on_windows_i_dont_remember_the_commands_but_will_set_up_a_vm_to_test_this_but_these_commands_should_have_windows_equivalents_if_you_run_into_any_issues_please_create_a_github_issue_on_the_repository_as_it_will_help_me_manage_different_issues_with_different_people_and_also_create_a_resource_for_people_encountering_a_solved_issue","text":"","title":"Please note, all these are for macOS/linux. I need to test on windows (I don't remember the commands, but will set up a VM to test this). But these commands should have windows equivalents. If you run into any issues please create a Github issue on the repository as it will help me manage different issues with different people and also create a resource for people encountering a solved issue."},{"location":"#anaconda","text":"Make sure you have anaconda installed: https://www.anaconda.com/download Download or clone this repository. In the conda prompt, navigate to the folder where you downloaded this repository using : cd \"path_to_folder\" Using the SMS_BP.yml file, create a new environment using: conda env create -f SMS_BP.yml If you get an environment resolve error but you have anaconda installed just skip to step 6. The .yml file is for people who are using miniconda and might not have the packages already installed with the full anaconda install. You may want to still have a conda environment so just create a generic one if you want with the name SMS_BP or whatever you want with python>=3.10. Explicitly, conda create -n [my_env_name] python=3.10.13 Activate the environment using: conda activate SMS_BP Now we will install this package in edit mode. Run the command: pip install -e . --config-settings editable_mode=compat","title":"Anaconda"},{"location":"#pip","text":"Make sure you have pip installed: https://pip.pypa.io/en/stable/installing/ Make sure you have python 3.10.13 as the active interpreter (through venv or conda or whatever you want). Make sure pip is also installed. Install from pypi using: pip install SMS-BP","title":"Pip"},{"location":"#installing_the_cli_tool_using_uv","text":"Install UV (https://docs.astral.sh/uv/getting-started/installation/). Run the command: uv tool install SMS_BP You will have access to two CLI commands (using the uv interface): run_SMS_BP runsim : This is the main entry point for the simulation. (see run_SMS_BP runsim --help for more details) run_SMS_BP config : This is a helper tool to generate a template config file for the simulation. (see run_SMS_BP config --help for more details) Note: using run_SMS_BP --help will show you all the available commands. You can now use these tools (they are isolated in their own env created by uv, which is cool): run_SMS_BP config [PATH_TO_CONFIG_FILE] run_SMS_BP runsim [PATH_TO_SAVED_CONFIG_FILE]","title":"Installing the CLI tool using UV"},{"location":"#2_running_the_simulation","text":"Having installed the package, make sure the CLI commands are working: run_SMS_BP --help If this does not work submit an issue on the github repository. TODO: convert this into tests. This is a note on using the CLI tool properly. In the install (step 6) we also installed a CLI tool to interface with the program from anywhere. The only condition is that you are in the SMS_BP conda environment or similar venv you created and installed to (unless you used uv). Create a template of the config file with default parameters using bash run_SMS_BP config [PATH_TO_CONFIG_FILE] This will create a sim_config.json file in the current directory. You can add a optional argument (path) to be a [PATH] to save the file elsewhere. To run the CLI tool after the install we can type bash run_SMS_BP runsim [PATH_TO_SAVED_CONFIG_FILE] If you used 1) then this is just: bash run_SMS_BP runsim sim_config.json from anywhere assuming the path you provide is absolute. In the background all this is doing is running: python from SMS_BP.run_cell_simulation import typer_app_sms_bp; typer_app_sms_bp() This is the entry point. Do note that the config checker is not robust so if you have prodived the wrong types or excluded some parameters which are required alongside other ones you will get an error. Read the src/SMS_BP/sim_config.md for details into the config file parameters. TODO: create CI tests for this. If you run into any issues please create a Github issue on the repository as it will help me manage different issues with different people and also create a resource for people encountering a solved issue.","title":"2. Running the Simulation"},{"location":"User_Guide_MD/","text":"SMS_BP User Guide # 1. Introduction # The goal of the SMS_BP package is 3 fold: Simulate motion of molecules with 3 properties: Follow FBM (fractional brownian motion) Be bounded (3D by the cell boundary) Molecule motion can change in time based on some user input probability of change to/from states (allowable states are the Diffusivity ( \\(\\frac{\\mu m ^{2}}{s^{\\alpha}}\\) ) and the Hurst exponent characterizing the correlations in the process' increments ( \\(\\alpha\\) ). Model the motion of condensates (and their size). This dictates a preferential location inside the cell where the probability of observing a molecule is higher than the rest of the cell. Multiple number of condensates can coexist and move independently. The probability of finding a molecule is then set to a user defined value of the partition coefficient of the condensates. Combine these two underlying processes and create realistic Single Molecule Tracking Photoactivatible Localization Microscopy movies and images which can be used to train tracking methods or analysis methods for molecule trajectories and cluster detection. These need to incorporate the photo-physics of the probe used, along with the optics of the microscopy and camera detection. Namely, it needs to allow for: motion blur defocus intensity decay defocus PSF deformation blinking (ON/OFF) of the probe. ::: info This is not a technical document. I am not discussing how these features are implemented (i think i came up with really nice solutions and would love to talk about it) but to display the large functionality of this code base and how you the user can interact with and use it for your own means. ::: 2. Simulation of Bounded FBM (n-dimensional) # The first order of business is to confirm that SMS_BP can simulate BM,FBM given some boundary. Here boundary conditions are implemented as reflecting. For the included plots im showing only 2D motion because it's easier to visualize but don't worry, the real simulation is 3D! In fact using the nice property of stationary increments of FBM you can use this to simulate n-dimensional motion (why you would want to do this I don't know, but you can)! Example of an effectively unconfined random motion where the increments are so small and the duration is not larget enough to encounter the boundary. We can simulate the correct D, \\(\\alpha\\) ! Don't worry the boundary is not set in stone and can be user defined. However it must be rectangular. Example of an effectively unconfined subdiffusive motion where the increments are so small and the duration is not large enough to encounter the boundary. We can simulate the correct D, \\(\\alpha\\) ! Example of an confined superdiffusive motion where the increments are large enough to encounter the boundary. We can simulate the correct D, \\(\\alpha\\) ! Example of an confined superdiffusive motion where the increments are large enough to be totally confined by the boundary. We can simulate the correct D, \\(\\alpha\\) but the extracted fits suffer because of the interactions at the boundary interface! Example of an confined transitioning motion. Here there are 4 states: 2 unique D, and 2 unique Hurst. The ensemble MSD is now a population average of for these and will greatly depend on the D,H values but also on the proportion of each state! The example of Figure 5 showed the transitioning ability of the simulation. Here I show if the user you ) gives the rates of transitioning from one state to another (and itself) SMS_BP can accurately simulate the correct transitioning proportions. As a note, this is assuming the process is Markovian and as such is implemented under-the-hood as a MCMC (Markov chain monte carlo). I want to emphasize that I only used 4 unique states here. In fact the user can ask for any combination of these (as many as you want) and the probabilities are all handled under-the-hood. You do not need to worry about typing anything other than the input parameters. I will discuss in future sections how you can define the parameters of the simulations and run it! By this point we have shown that the first goal is accomplished. Lets move on to the condensate! 3. Condensate Definitions and Movement # So far we have worked with individual trajectories and let them start at the origin. What if we want to simulate many trajectories (molecule motion) but starting at different places in the cells? One choice is to randomly sample the cellular space and start the observation of a molecule. But if the underlying space is heterogeneous in the density of molecules we are tracing we can define the cellular space as a probability space. Each spatial element defines the expected probability of finding a molecule in that region. This framework leads to the definition of a condensate! A condensate in the framework of SMS_BP is defined as a circular/spherical region in the cell which has a higher probability per unit volume to find a molecule. That it, so simple! The nice consequence of using this simple definition is that we can also model the motion of the condensate by using the probability space. By letting the probability space be time dependent Figure 7 shows that we can treat the condensate as a moving trajectory itself and using the framework we developed previously to model its motion as BM or FBM! Isn't that cool? Here we can simulate any number of condensates (here I show 2). Implementation wise, their motion is independent of one another. But using the framework of the FBM from before we can model the condensates motion in anyway we like. Here one condensate is subdiffusive with a small diffusion coefficient and one which is super-diffusive with a larger diffusion coefficient. The blue lines represent the motion of the centre of each condensate. The red circles show the extent of the condensate boundary. In this case the size (radius) of the condensate does not change in time. But rest assured, SMS_BP allows you to change this as you like! Since these objects are built on the same framework as the FBM, they share all the features of the molecule motion we outlined before. Again you should think of the condensate as a probability space which is time and space dependent, \\(p(s,t)\\) . This condensate movement occurs in the background of the true molecule simulation and informs the location of the individual molecule positions as they turn on to their fluorescent state. This is parameterized by a probability density defined by the user which we will talk about later. For now bask in the glory that is SMS_BP. 4. Conversion of Backend Trajectories to Observable PALM-like Images # Okay all of the previous features are considered the backend of the simulation. They define what process are occurring. Our job now is to express these processes in a way which is similar to what an experimenter would observe from a typical SMT experiment. There are 3 things to consider: getting the photo-physics (intensities, PSF, etc ..) correct, modelling the effect of motion blurring, and the affect of the focal depth. The first is not that hard, assuming we have knowledge of the properties of the PSF and the intensities (photon counts) of individual molecule localizations (at a given exposure) we can define the mean photons emitted and captured at the detector in a time frame. The issue is the motion blurring. Since this is affected by fast motion and corresponding long exposures we actually sample the motion of the trajectories at a smaller time resolution than the exposure time! For example, if the exposure time is 100 ms the camera is on for 100 ms capturing photons emitted. Meanwhile the underlying molecule is still moving so rather than simulating the motion at 100 ms intervals we can simulate it at a smaller interval ( \\(t < 100ms\\) ) and integrate the photons over the exposure time, 100ms. For fast moving molecules which would resemble comet tails as the intensity (the photons) would leave a trail of photons in its wake over the time the detector is on. SMS_BP allows the user to define the smaller sample time, \\(t\\) . For example, in Figure 8 I show the effect of a sample time smaller than the exposure time. For visual aid I have cranked up the mean photons emitted/captured to make the comet tail readily apparent. You can change all these parameters, and we will do this in the final section. Here the motion of a molecule is sampled every 1 ms. The exposure time is 20 ms and there is no interval time between measurements. All three of these parameters ca be user defined! Notice at this particualar frame the PSF of the molecule appears distorted? This is because of motion blur and defocus modelled by SMS_BP. For visual aid I have artificially increased the mean photons emitted/captured for this molecule. The image is slightly ugly due to png compression, but you will get to make your own simulations and appreciate the details. Here the motion of a molecule is sampled every 20 ms. The exposure time is 20 ms and there is no interval time between measurements. Notice there is no PSF deformation in this frame, since the molecule is modelled every 20 ms from the point of view of the simulation nothing occurs in the interval. This is because of there is no modelled motion blur and defocus by SMS_BP. Compared to Figure 8 the only difference is that the over sampling (the \\(t\\) I discuss in the text) is the same as the exposure time in this particular case. For visual aid I have artificially increased the mean photons emitted/captured for this molecule. 5. Working With the Code # First things first: use the installing instructions in the main README.md to get the conda environment created and the package installed on your system. This allows you to use the functionality of SMS_BP from anywhere since the path is appended to the main python search path. There are 2 different ways to interact with the code. In the install we also install a CLI command run_SMS_BP which will work globally (you do not need to be in the directory of the project). You will need to provide a config file location to this command or it will be unhappy with you. You can run run_SMS_BP --help to see uses. The second is to use the actual code itself through import. We can do this since we have installed the code as a package. To keep it simple for now let's focus on the first method. We can run the CLI command: run_SMS_BP config [PATH_TO_CONFIG_FILE] This will create a template config file in the current directory if [PATH_TO_CONFIG_FILE] is set to \".\". You can change the . to be a [PATH] to save the file elsewhere. In this newly created template file you will see a nested dictionary with a bunch of parameters and associated values. We will go over each of these and what values are allowable. The document sim_config.md is a text file describing each parameter and the units of each parameter in our main sim_config.json. Use it as a reference if you want to change any of the parameters later on. First of all. Let's change one parameter in the sim_config.json. Find the set of parameters called \\\"Output_Parameters\\\". Inside you will find a parameter called \\\"output_path\\\". Currently it contains a placeholder. Change this to a string which is the absolute path of the place you want SMS_BP to store the final results. So to reiterate change the string \\\"\\<YOUR-PATH-HERE-CAN-BE-ABSOLUTE-OR-RELATIVE>\\\" to the path you want. We can keep the rest of the parameters the same for now and let's just run the simulation. Run using run_SMS_BP runsim sim_config.json Once the simulation finishes you will find a new folder created at the path you specified and inside a few files and folders. For now ignore the folders. The .tiff file is the movie of the simulation. params_dump.json is a copy of the sim_config.json used to create this particular simulation, it is also provided as a pickle file. The final file Track_dump.pkl is the true simulation of the underlying motion we did in section 1. This allows you to track the PSFs in the movie and compare back to the true positions of the molecules to see how well you did! Let's redo this but now with the variable oversample_motion_time equal to the exposure_time. Set both to 20 (ms). Notice any difference in the two output movies? This is all I did to create figures 8-9. To do further changes in the simulation I recommend reading the sim_config.md file explaining the role of each parameter in the sim_config.json file. If required I might make tutorials for other features I did not discuss here.","title":"Starter Guide"},{"location":"User_Guide_MD/#sms_bp_user_guide","text":"","title":"SMS_BP User Guide"},{"location":"User_Guide_MD/#1_introduction","text":"The goal of the SMS_BP package is 3 fold: Simulate motion of molecules with 3 properties: Follow FBM (fractional brownian motion) Be bounded (3D by the cell boundary) Molecule motion can change in time based on some user input probability of change to/from states (allowable states are the Diffusivity ( \\(\\frac{\\mu m ^{2}}{s^{\\alpha}}\\) ) and the Hurst exponent characterizing the correlations in the process' increments ( \\(\\alpha\\) ). Model the motion of condensates (and their size). This dictates a preferential location inside the cell where the probability of observing a molecule is higher than the rest of the cell. Multiple number of condensates can coexist and move independently. The probability of finding a molecule is then set to a user defined value of the partition coefficient of the condensates. Combine these two underlying processes and create realistic Single Molecule Tracking Photoactivatible Localization Microscopy movies and images which can be used to train tracking methods or analysis methods for molecule trajectories and cluster detection. These need to incorporate the photo-physics of the probe used, along with the optics of the microscopy and camera detection. Namely, it needs to allow for: motion blur defocus intensity decay defocus PSF deformation blinking (ON/OFF) of the probe. ::: info This is not a technical document. I am not discussing how these features are implemented (i think i came up with really nice solutions and would love to talk about it) but to display the large functionality of this code base and how you the user can interact with and use it for your own means. :::","title":"1. Introduction"},{"location":"User_Guide_MD/#2_simulation_of_bounded_fbm_n-dimensional","text":"The first order of business is to confirm that SMS_BP can simulate BM,FBM given some boundary. Here boundary conditions are implemented as reflecting. For the included plots im showing only 2D motion because it's easier to visualize but don't worry, the real simulation is 3D! In fact using the nice property of stationary increments of FBM you can use this to simulate n-dimensional motion (why you would want to do this I don't know, but you can)! Example of an effectively unconfined random motion where the increments are so small and the duration is not larget enough to encounter the boundary. We can simulate the correct D, \\(\\alpha\\) ! Don't worry the boundary is not set in stone and can be user defined. However it must be rectangular. Example of an effectively unconfined subdiffusive motion where the increments are so small and the duration is not large enough to encounter the boundary. We can simulate the correct D, \\(\\alpha\\) ! Example of an confined superdiffusive motion where the increments are large enough to encounter the boundary. We can simulate the correct D, \\(\\alpha\\) ! Example of an confined superdiffusive motion where the increments are large enough to be totally confined by the boundary. We can simulate the correct D, \\(\\alpha\\) but the extracted fits suffer because of the interactions at the boundary interface! Example of an confined transitioning motion. Here there are 4 states: 2 unique D, and 2 unique Hurst. The ensemble MSD is now a population average of for these and will greatly depend on the D,H values but also on the proportion of each state! The example of Figure 5 showed the transitioning ability of the simulation. Here I show if the user you ) gives the rates of transitioning from one state to another (and itself) SMS_BP can accurately simulate the correct transitioning proportions. As a note, this is assuming the process is Markovian and as such is implemented under-the-hood as a MCMC (Markov chain monte carlo). I want to emphasize that I only used 4 unique states here. In fact the user can ask for any combination of these (as many as you want) and the probabilities are all handled under-the-hood. You do not need to worry about typing anything other than the input parameters. I will discuss in future sections how you can define the parameters of the simulations and run it! By this point we have shown that the first goal is accomplished. Lets move on to the condensate!","title":"2. Simulation of Bounded FBM (n-dimensional)"},{"location":"User_Guide_MD/#3_condensate_definitions_and_movement","text":"So far we have worked with individual trajectories and let them start at the origin. What if we want to simulate many trajectories (molecule motion) but starting at different places in the cells? One choice is to randomly sample the cellular space and start the observation of a molecule. But if the underlying space is heterogeneous in the density of molecules we are tracing we can define the cellular space as a probability space. Each spatial element defines the expected probability of finding a molecule in that region. This framework leads to the definition of a condensate! A condensate in the framework of SMS_BP is defined as a circular/spherical region in the cell which has a higher probability per unit volume to find a molecule. That it, so simple! The nice consequence of using this simple definition is that we can also model the motion of the condensate by using the probability space. By letting the probability space be time dependent Figure 7 shows that we can treat the condensate as a moving trajectory itself and using the framework we developed previously to model its motion as BM or FBM! Isn't that cool? Here we can simulate any number of condensates (here I show 2). Implementation wise, their motion is independent of one another. But using the framework of the FBM from before we can model the condensates motion in anyway we like. Here one condensate is subdiffusive with a small diffusion coefficient and one which is super-diffusive with a larger diffusion coefficient. The blue lines represent the motion of the centre of each condensate. The red circles show the extent of the condensate boundary. In this case the size (radius) of the condensate does not change in time. But rest assured, SMS_BP allows you to change this as you like! Since these objects are built on the same framework as the FBM, they share all the features of the molecule motion we outlined before. Again you should think of the condensate as a probability space which is time and space dependent, \\(p(s,t)\\) . This condensate movement occurs in the background of the true molecule simulation and informs the location of the individual molecule positions as they turn on to their fluorescent state. This is parameterized by a probability density defined by the user which we will talk about later. For now bask in the glory that is SMS_BP.","title":"3. Condensate Definitions and Movement"},{"location":"User_Guide_MD/#4_conversion_of_backend_trajectories_to_observable_palm-like_images","text":"Okay all of the previous features are considered the backend of the simulation. They define what process are occurring. Our job now is to express these processes in a way which is similar to what an experimenter would observe from a typical SMT experiment. There are 3 things to consider: getting the photo-physics (intensities, PSF, etc ..) correct, modelling the effect of motion blurring, and the affect of the focal depth. The first is not that hard, assuming we have knowledge of the properties of the PSF and the intensities (photon counts) of individual molecule localizations (at a given exposure) we can define the mean photons emitted and captured at the detector in a time frame. The issue is the motion blurring. Since this is affected by fast motion and corresponding long exposures we actually sample the motion of the trajectories at a smaller time resolution than the exposure time! For example, if the exposure time is 100 ms the camera is on for 100 ms capturing photons emitted. Meanwhile the underlying molecule is still moving so rather than simulating the motion at 100 ms intervals we can simulate it at a smaller interval ( \\(t < 100ms\\) ) and integrate the photons over the exposure time, 100ms. For fast moving molecules which would resemble comet tails as the intensity (the photons) would leave a trail of photons in its wake over the time the detector is on. SMS_BP allows the user to define the smaller sample time, \\(t\\) . For example, in Figure 8 I show the effect of a sample time smaller than the exposure time. For visual aid I have cranked up the mean photons emitted/captured to make the comet tail readily apparent. You can change all these parameters, and we will do this in the final section. Here the motion of a molecule is sampled every 1 ms. The exposure time is 20 ms and there is no interval time between measurements. All three of these parameters ca be user defined! Notice at this particualar frame the PSF of the molecule appears distorted? This is because of motion blur and defocus modelled by SMS_BP. For visual aid I have artificially increased the mean photons emitted/captured for this molecule. The image is slightly ugly due to png compression, but you will get to make your own simulations and appreciate the details. Here the motion of a molecule is sampled every 20 ms. The exposure time is 20 ms and there is no interval time between measurements. Notice there is no PSF deformation in this frame, since the molecule is modelled every 20 ms from the point of view of the simulation nothing occurs in the interval. This is because of there is no modelled motion blur and defocus by SMS_BP. Compared to Figure 8 the only difference is that the over sampling (the \\(t\\) I discuss in the text) is the same as the exposure time in this particular case. For visual aid I have artificially increased the mean photons emitted/captured for this molecule.","title":"4. Conversion of Backend Trajectories to Observable PALM-like Images"},{"location":"User_Guide_MD/#5_working_with_the_code","text":"First things first: use the installing instructions in the main README.md to get the conda environment created and the package installed on your system. This allows you to use the functionality of SMS_BP from anywhere since the path is appended to the main python search path. There are 2 different ways to interact with the code. In the install we also install a CLI command run_SMS_BP which will work globally (you do not need to be in the directory of the project). You will need to provide a config file location to this command or it will be unhappy with you. You can run run_SMS_BP --help to see uses. The second is to use the actual code itself through import. We can do this since we have installed the code as a package. To keep it simple for now let's focus on the first method. We can run the CLI command: run_SMS_BP config [PATH_TO_CONFIG_FILE] This will create a template config file in the current directory if [PATH_TO_CONFIG_FILE] is set to \".\". You can change the . to be a [PATH] to save the file elsewhere. In this newly created template file you will see a nested dictionary with a bunch of parameters and associated values. We will go over each of these and what values are allowable. The document sim_config.md is a text file describing each parameter and the units of each parameter in our main sim_config.json. Use it as a reference if you want to change any of the parameters later on. First of all. Let's change one parameter in the sim_config.json. Find the set of parameters called \\\"Output_Parameters\\\". Inside you will find a parameter called \\\"output_path\\\". Currently it contains a placeholder. Change this to a string which is the absolute path of the place you want SMS_BP to store the final results. So to reiterate change the string \\\"\\<YOUR-PATH-HERE-CAN-BE-ABSOLUTE-OR-RELATIVE>\\\" to the path you want. We can keep the rest of the parameters the same for now and let's just run the simulation. Run using run_SMS_BP runsim sim_config.json Once the simulation finishes you will find a new folder created at the path you specified and inside a few files and folders. For now ignore the folders. The .tiff file is the movie of the simulation. params_dump.json is a copy of the sim_config.json used to create this particular simulation, it is also provided as a pickle file. The final file Track_dump.pkl is the true simulation of the underlying motion we did in section 1. This allows you to track the PSFs in the movie and compare back to the true positions of the molecules to see how well you did! Let's redo this but now with the variable oversample_motion_time equal to the exposure_time. Set both to 20 (ms). Notice any difference in the two output movies? This is all I did to create figures 8-9. To do further changes in the simulation I recommend reading the sim_config.md file explaining the role of each parameter in the sim_config.json file. If required I might make tutorials for other features I did not discuss here.","title":"5. Working With the Code"},{"location":"license/","text":"License # Copyright (c) [2024] Baljyot Singh Parmar [All rights reserved]. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. THIS SOFTWARE IS PROVIDED BY Baljyot Singh Parmar \u201cAS IS\u201d AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL [Baljyot Singh Parmar] BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"License"},{"location":"license/#license","text":"Copyright (c) [2024] Baljyot Singh Parmar [All rights reserved]. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. THIS SOFTWARE IS PROVIDED BY Baljyot Singh Parmar \u201cAS IS\u201d AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL [Baljyot Singh Parmar] BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"License"},{"location":"sim_config/","text":"Documentation for the simulation configuration file of the same name # Simulation Configuration File Latest version supported: v.0.1 Simulation Configuration File # version: string version of the simulation configuration file length_unit: string length unit of the simulation (e.g. nm, um, mm) space_unit: string space unit of the simulation (this is just pixel, should not change) time_unit: string time unit of the simulation (e.g. s, ms, us) intensity_unit: string intensity unit of the simulation (AUD only supported) diffusion_unit: string diffusion unit of the simulation (e.g. um^2/s, mm^2/s) Cell_Parameters: dict cell_space: 2D array (units of space_unit) cell_space[0]: x coordinates of the cell space (min, max) cell_space[1]: y coordinates of the cell space (min, max) cell_axial_radius: float (units of space_unit) The distance from z=0 in either direction that the cell extends number_of_cells: int number of cells to simulate (if more than 1 hen all are simulated in one folder defined by the output_path) Track_Parameters: dict num_tracks: int number of tracks to simulate track_type: string type of track to simulate (\"fbm\") track_length_mean: int (frames) mean length of the track track_distribution: string distribution of the track lengths (\"exponential\",\"constant\") diffusion_coefficient: list of floats (units of diffusion_unit) diffusion coefficient of the track, the length of the list is the unique type of diffusion coefficients diffusion_track_amount: list of floats Only viable if allow_transition_probability is False length is the total number of diffusion coefficients each element is the probability of the track having the diffusion coefficient at the same index in the diffusion_coefficient list (add up to 1.0) hurst_expontent: list of floats hurst exponent of the track, the length of the list is the unique type of hurst exponents hurst_track_amount: list of floats Only viable if allow_transition_probability is False length is the total number of hurst exponents each element is the probability of the track having the hurst exponent at the same index in the hurst_exponent list (add up to 1.0) allow_transition_probability: bool whether to allow transition probabilities between different diffusion coefficients and hurst exponents within a track if false, the track will have a single diffusion coefficient and hurst exponent transition_matrix_time_step: int time step at which the diffusion and hurst exponent transition matrices are supplied in the following parameters the units are in time_unit (so 100 ms would be 100) diffusion_transition_matrix: 2D array (discrete state probabilitiy at the transition_matrix_time_step = dt) transition matrix between different diffusion coefficients rows are the current diffusion coefficient columns are the next diffusion coefficient rows must sum to 1.0 hurst_transition_matrix: 2D array (discrete state probabilitiy at the transition_matrix_time_step = dt) transition matrix between different hurst exponents rows are the current hurst exponent columns are the next hurst exponent rows must sum to 1.0 state_probability_diffusion: 1D array (probability) probability of a track being in a certain diffusion coefficient state length is the number of unique diffusion coefficients state_probability_hurst: 1D array (probability) probability of a track being in a certain hurst exponent state length is the number of unique hurst exponents Global_Parameters: dict field_of_view_dim: 1D array (units of space_unit) field of view dimensions (x,y (pixels)) frame_count: int number of frames to simulate exposure_time: float or int (units of time_unit) exposure time of the camera interval_time: float or int (units of time_unit) time between frames that the camera is on oversample_motion_time: float or int (units of time_unit) oversampling the motion for motion blur if oversample_motion_time == frame_time == exposure_time, then there is no motion blur cannot be greater than frame_time or exposure_time pixel_size: float (units of length_unit) size of the pixel axial_detection_range: float (units of length_unit) from z=0, the distance in either direction that the camera can detect a single molecule excitation base_noise: float (units of intensity_unit) base noise of the camera (offset) point_intensity: float (units of intensity_unit) intensity of a single molecule excitation psf_sigma: float (units of length_unit) size of the psf (assumed to be gaussian) axial_function: string (\"exponential\",\"ones\"(no effect)) function used to determine how the intensity of the single molecule changes with z Condenstate_Parameters: dict initial_centers: 2D array (units of space_unit) initial centers of the condensates [x,y,z] coordinates per row number of rows is the number of condensates initial_scale: 1D (units of space_unit) initial radius of the condensates number of elements is the number of condensates must be the same length as initial_centers diffusion_coefficient: 1D array (units of diffusion_unit) diffusion coefficient of the condensates number of elements is the number of condensates must be the same length as initial_centers hurst_exponent: 1D array hurst exponent of the condensates number of elements is the number of condensates must be the same length as initial_centers density_dif: float density difference between the condensates and the rest of the cell Output_Parameters: dict output_path: string path to save the output, directory output_name: string name of the output file *subsegment_type: string function used to do projections (\"mean\",\"max\",\"sum\") subsegment_number: int number of subsegments to divide the cell frames into if total movie is 500 frames and this is 5 then there will be 100 frames per subsegment and 5 subsegments in total Make sure that the total number of frames is divisible by the number of subsegments (modulus is 0)","title":"sim_config Documentation"},{"location":"sim_config/#documentation_for_the_simulation_configuration_file_of_the_same_name","text":"Simulation Configuration File Latest version supported: v.0.1","title":"Documentation for the simulation configuration file of the same name"},{"location":"sim_config/#simulation_configuration_file","text":"version: string version of the simulation configuration file length_unit: string length unit of the simulation (e.g. nm, um, mm) space_unit: string space unit of the simulation (this is just pixel, should not change) time_unit: string time unit of the simulation (e.g. s, ms, us) intensity_unit: string intensity unit of the simulation (AUD only supported) diffusion_unit: string diffusion unit of the simulation (e.g. um^2/s, mm^2/s) Cell_Parameters: dict cell_space: 2D array (units of space_unit) cell_space[0]: x coordinates of the cell space (min, max) cell_space[1]: y coordinates of the cell space (min, max) cell_axial_radius: float (units of space_unit) The distance from z=0 in either direction that the cell extends number_of_cells: int number of cells to simulate (if more than 1 hen all are simulated in one folder defined by the output_path) Track_Parameters: dict num_tracks: int number of tracks to simulate track_type: string type of track to simulate (\"fbm\") track_length_mean: int (frames) mean length of the track track_distribution: string distribution of the track lengths (\"exponential\",\"constant\") diffusion_coefficient: list of floats (units of diffusion_unit) diffusion coefficient of the track, the length of the list is the unique type of diffusion coefficients diffusion_track_amount: list of floats Only viable if allow_transition_probability is False length is the total number of diffusion coefficients each element is the probability of the track having the diffusion coefficient at the same index in the diffusion_coefficient list (add up to 1.0) hurst_expontent: list of floats hurst exponent of the track, the length of the list is the unique type of hurst exponents hurst_track_amount: list of floats Only viable if allow_transition_probability is False length is the total number of hurst exponents each element is the probability of the track having the hurst exponent at the same index in the hurst_exponent list (add up to 1.0) allow_transition_probability: bool whether to allow transition probabilities between different diffusion coefficients and hurst exponents within a track if false, the track will have a single diffusion coefficient and hurst exponent transition_matrix_time_step: int time step at which the diffusion and hurst exponent transition matrices are supplied in the following parameters the units are in time_unit (so 100 ms would be 100) diffusion_transition_matrix: 2D array (discrete state probabilitiy at the transition_matrix_time_step = dt) transition matrix between different diffusion coefficients rows are the current diffusion coefficient columns are the next diffusion coefficient rows must sum to 1.0 hurst_transition_matrix: 2D array (discrete state probabilitiy at the transition_matrix_time_step = dt) transition matrix between different hurst exponents rows are the current hurst exponent columns are the next hurst exponent rows must sum to 1.0 state_probability_diffusion: 1D array (probability) probability of a track being in a certain diffusion coefficient state length is the number of unique diffusion coefficients state_probability_hurst: 1D array (probability) probability of a track being in a certain hurst exponent state length is the number of unique hurst exponents Global_Parameters: dict field_of_view_dim: 1D array (units of space_unit) field of view dimensions (x,y (pixels)) frame_count: int number of frames to simulate exposure_time: float or int (units of time_unit) exposure time of the camera interval_time: float or int (units of time_unit) time between frames that the camera is on oversample_motion_time: float or int (units of time_unit) oversampling the motion for motion blur if oversample_motion_time == frame_time == exposure_time, then there is no motion blur cannot be greater than frame_time or exposure_time pixel_size: float (units of length_unit) size of the pixel axial_detection_range: float (units of length_unit) from z=0, the distance in either direction that the camera can detect a single molecule excitation base_noise: float (units of intensity_unit) base noise of the camera (offset) point_intensity: float (units of intensity_unit) intensity of a single molecule excitation psf_sigma: float (units of length_unit) size of the psf (assumed to be gaussian) axial_function: string (\"exponential\",\"ones\"(no effect)) function used to determine how the intensity of the single molecule changes with z Condenstate_Parameters: dict initial_centers: 2D array (units of space_unit) initial centers of the condensates [x,y,z] coordinates per row number of rows is the number of condensates initial_scale: 1D (units of space_unit) initial radius of the condensates number of elements is the number of condensates must be the same length as initial_centers diffusion_coefficient: 1D array (units of diffusion_unit) diffusion coefficient of the condensates number of elements is the number of condensates must be the same length as initial_centers hurst_exponent: 1D array hurst exponent of the condensates number of elements is the number of condensates must be the same length as initial_centers density_dif: float density difference between the condensates and the rest of the cell Output_Parameters: dict output_path: string path to save the output, directory output_name: string name of the output file *subsegment_type: string function used to do projections (\"mean\",\"max\",\"sum\") subsegment_number: int number of subsegments to divide the cell frames into if total movie is 500 frames and this is 5 then there will be 100 frames per subsegment and 5 subsegments in total Make sure that the total number of frames is divisible by the number of subsegments (modulus is 0)","title":"Simulation Configuration File"}]}