{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Hello and Install","text":""},{"location":"#single_molecule_simulations_-_bp","title":"Single Molecule Simulations - BP","text":"<ul> <li>Author: Baljyot Singh Parmar</li> <li>Affiliation at the time of writing: McGill University, Canada. Weber Lab</li> </ul> <p>Please read the User Guide for details on the features of this project along with some examples.</p>"},{"location":"#1_installation","title":"1. Installation","text":""},{"location":"#anaconda","title":"Anaconda","text":"<ol> <li>Make sure you have anaconda installed: https://www.anaconda.com/download</li> <li>Download or clone this repository.</li> <li>In the conda prompt, navigate to the folder where you downloaded this repository using : </li> </ol> <pre><code>cd \"path_to_folder\"\n</code></pre> <ol> <li>Using the SMS_BP.yml file, create a new environment using: </li> </ol> <pre><code>conda env create -f SMS_BP.yml\n</code></pre> <ul> <li>If you get an environment resolve error but you have anaconda installed just skip to step 6. The .yml file is for people who are using miniconda and might not have the packages already installed with the full anaconda install.</li> <li>You may want to still have a conda environment so just create a generic one if you want with the name SMS_BP or whatever you want with python&gt;=3.12. Explicitly, </li> </ul> <pre><code>conda create -n [my_env_name] python=3.12\n</code></pre> <ol> <li>Activate the environment using: </li> </ol> <pre><code>conda activate SMS_BP\n</code></pre> <ol> <li>Now we will install this package in edit mode.<ul> <li>Run the command:</li> </ul> </li> </ol> <pre><code>pip install -e . --config-settings editable_mode=compat\n</code></pre>"},{"location":"#pip","title":"Pip","text":"<ol> <li>Make sure you have pip installed: https://pip.pypa.io/en/stable/installing/</li> <li>Make sure you have python 3.10.13 as the active interpreter (through venv or conda or whatever you want).</li> <li>Make sure pip is also installed.</li> <li>Install from pypi using: </li> </ol> <pre><code>pip install SMS-BP\n</code></pre>"},{"location":"#installing_the_cli_tool_using_uv","title":"Installing the CLI tool using UV","text":"<ol> <li>Install UV (https://docs.astral.sh/uv/getting-started/installation/).</li> <li>Run the command:</li> </ol> <pre><code>uv tool install SMS_BP\n</code></pre> <ol> <li>You will have access to two CLI commands (using the uv interface):<ul> <li><code>run_SMS_BP runsim</code> : This is the main entry point for the simulation. (see <code>run_SMS_BP runsim --help</code> for more details)</li> <li><code>run_SMS_BP config</code> : This is a helper tool to generate a template config file for the simulation. (see <code>run_SMS_BP config --help</code> for more details)</li> <li>Note: using <code>run_SMS_BP --help</code> will show you all the available commands.</li> </ul> </li> <li>You can now use these tools (they are isolated in their own env created by uv, which is cool): </li> </ol> <pre><code>run_SMS_BP config [PATH_TO_CONFIG_FILE]\n</code></pre> <pre><code>run_SMS_BP runsim [PATH_TO_SAVED_CONFIG_FILE]\n</code></pre>"},{"location":"#2_running_the_simulation","title":"2. Running the Simulation","text":"<p>Having installed the package, make sure the CLI commands are working:</p> <pre><code>run_SMS_BP --help\n</code></pre> <p>If this does not work submit an issue on the github repository. TODO: convert this into tests.</p> <ol> <li>This is a note on using the CLI tool properly. In the install (step 6) we also installed a CLI tool to interface with the program from anywhere. The only condition is that you are in the SMS_BP conda environment or similar venv you created and installed to (unless you used uv). <ul> <li>Create a template of the config file with default parameters using  <code>bash run_SMS_BP config [PATH_TO_CONFIG_FILE]</code> This will create a sim_config.json file in the current directory. You can add a optional argument (path) to be a [PATH] to save the file elsewhere.</li> <li>To run the CLI tool after the install we can type  <code>bash run_SMS_BP runsim [PATH_TO_SAVED_CONFIG_FILE]</code></li> <li>If you used 1) then this is just: <code>bash run_SMS_BP runsim sim_config.json</code> from anywhere assuming the path you provide is absolute.</li> <li>In the background all this is doing is running:  <code>python from SMS_BP.run_cell_simulation import typer_app_sms_bp; typer_app_sms_bp()</code> This is the entry point.</li> <li>Do note that the config checker is not robust so if you have prodived the wrong types or excluded some parameters which are required alongside other ones you will get an error. Read the src/SMS_BP/sim_config.md for details into the config file parameters. TODO: create CI tests for this.</li> </ul> </li> <li>If you run into any issues please create a Github issue on the repository as it will help me manage different issues with different people and also create a resource for people encountering a solved issue.</li> </ol>"},{"location":"User_Guide_MD/","title":"Starter Guide","text":""},{"location":"User_Guide_MD/#sms_bp_user_guide","title":"SMS_BP User Guide","text":""},{"location":"User_Guide_MD/#1_introduction","title":"1. Introduction","text":"<p>The goal of the SMS_BP package is 3 fold:</p> <ol> <li> <p>Simulate motion of molecules with 3 properties:</p> <ol> <li> <p>Follow FBM (fractional brownian motion)</p> </li> <li> <p>Be bounded (3D by the cell boundary)</p> </li> <li> <p>Molecule motion can change in time based on some user input     probability of change to/from states (allowable states are the     Diffusivity (\\(\\frac{\\mu m ^{2}}{s^{\\alpha}}\\)) and the Hurst     exponent characterizing the correlations in the process'     increments (\\(\\alpha\\)).</p> </li> </ol> </li> <li> <p>Model the motion of condensates (and their size). This dictates a     preferential location inside the cell where the probability of     observing a molecule is higher than the rest of the cell. Multiple     number of condensates can coexist and move independently. The     probability of finding a molecule is then set to a user defined     value of the partition coefficient of the condensates.</p> </li> <li> <p>Combine these two underlying processes and create realistic Single     Molecule Tracking Photoactivatible Localization Microscopy movies     and images which can be used to train tracking methods or analysis     methods for molecule trajectories and cluster detection. These need     to incorporate the photo-physics of the probe used, along with the     optics of the microscopy and camera detection. Namely, it needs to     allow for:</p> <ol> <li> <p>motion blur</p> </li> <li> <p>defocus intensity decay</p> </li> <li> <p>defocus PSF deformation</p> </li> <li> <p>blinking (ON/OFF) of the probe.</p> </li> </ol> </li> </ol> <p>This is not a technical document. I am not discussing how these features are implemented (i think i came up with really nice solutions and would love to talk about it) but to display the large functionality of this code base and how you the user can interact with and use it for your own means.</p>"},{"location":"User_Guide_MD/#2_simulation_of_bounded_fbm_n-dimensional","title":"2. Simulation of Bounded FBM (n-dimensional)","text":"<p>The first order of business is to confirm that SMS_BP can simulate BM,FBM given some boundary. Here boundary conditions are implemented as reflecting. For the included plots im showing only 2D motion because it's easier to visualize but don't worry, the real simulation is 3D! In fact using the nice property of stationary increments of FBM you can use this to simulate n-dimensional motion (why you would want to do this I don't know, but you can)!</p> <p> Example of an effectively unconfined random motion where the increments are so small and the duration is not larget enough to encounter the boundary. We can simulate the correct D, \\(\\alpha\\)! Don't worry the boundary is not set in stone and can be user defined. However it must be rectangular.</p> <p> Example of an effectively unconfined subdiffusive motion where the increments are so small and the duration is not large enough to encounter the boundary. We can simulate the correct D, \\(\\alpha\\)!</p> <p> Example of an confined superdiffusive motion where the increments are large enough to encounter the boundary. We can simulate the correct D, \\(\\alpha\\)!</p> <p> Example of an confined superdiffusive motion where the increments are large enough to be totally confined by the boundary. We can simulate the correct D, \\(\\alpha\\) but the extracted fits suffer because of the interactions at the boundary interface!</p> <p> Example of an confined transitioning motion. Here there are 4 states: 2 unique D, and 2 unique Hurst. The ensemble MSD is now a population average of for these and will greatly depend on the D,H values but also on the proportion of each state!</p> <p> The example of Figure 5 showed the transitioning ability of the simulation. Here I show if the user you) gives the rates of transitioning from one state to another (and itself) SMS_BP can accurately simulate the correct transitioning proportions. As a note, this is assuming the process is Markovian and as such is implemented under-the-hood as a MCMC (Markov chain monte carlo).</p> <p>I want to emphasize that I only used 4 unique states here. In fact the user can ask for any combination of these (as many as you want) and the probabilities are all handled under-the-hood. You do not need to worry about typing anything other than the input parameters. I will discuss in future sections how you can define the parameters of the simulations and run it! By this point we have shown that the first goal is accomplished. Lets move on to the condensate!</p>"},{"location":"User_Guide_MD/#3_condensate_definitions_and_movement","title":"3. Condensate Definitions and Movement","text":"<p>So far we have worked with individual trajectories and let them start at the origin. What if we want to simulate many trajectories (molecule motion) but starting at different places in the cells? One choice is to randomly sample the cellular space and start the observation of a molecule. But if the underlying space is heterogeneous in the density of molecules we are tracing we can define the cellular space as a probability space. Each spatial element defines the expected probability of finding a molecule in that region. This framework leads to the definition of a condensate!</p> <p>A condensate in the framework of SMS_BP is defined as a circular/spherical region in the cell which has a higher probability per unit volume to find a molecule. That it, so simple! The nice consequence of using this simple definition is that we can also model the motion of the condensate by using the probability space. By letting the probability space be time dependent Figure 7 shows that we can treat the condensate as a moving trajectory itself and using the framework we developed previously to model its motion as BM or FBM! Isn't that cool?</p> <p> Here we can simulate any number of condensates (here I show 2). Implementation wise, their motion is independent of one another. But using the framework of the FBM from before we can model the condensates motion in anyway we like. Here one condensate is subdiffusive with a small diffusion coefficient and one which is super-diffusive with a larger diffusion coefficient. The blue lines represent the motion of the centre of each condensate. The red circles show the extent of the condensate boundary. In this case the size (radius) of the condensate does not change in time. But rest assured, SMS_BP allows you to change this as you like! Since these objects are built on the same framework as the FBM, they share all the features of the molecule motion we outlined before.</p> <p>Again you should think of the condensate as a probability space which is time and space dependent, \\(p(s,t)\\). This condensate movement occurs in the background of the true molecule simulation and informs the location of the individual molecule positions as they turn on to their fluorescent state. This is parameterized by a probability density defined by the user which we will talk about later. For now bask in the glory that is SMS_BP.</p>"},{"location":"User_Guide_MD/#4_conversion_of_backend_trajectories_to_observable_palm-like_images","title":"4. Conversion of Backend Trajectories to Observable PALM-like Images","text":"<p>Okay all of the previous features are considered the backend of the simulation. They define what process are occurring. Our job now is to express these processes in a way which is similar to what an experimenter would observe from a typical SMT experiment. There are 3 things to consider: getting the photo-physics (intensities, PSF, etc ..) correct, modelling the effect of motion blurring, and the affect of the focal depth.</p> <p>The first is not that hard, assuming we have knowledge of the properties of the PSF and the intensities (photon counts) of individual molecule localizations (at a given exposure) we can define the mean photons emitted and captured at the detector in a time frame. The issue is the motion blurring. Since this is affected by fast motion and corresponding long exposures we actually sample the motion of the trajectories at a smaller time resolution than the exposure time! For example, if the exposure time is 100 ms the camera is on for 100 ms capturing photons emitted. Meanwhile the underlying molecule is still moving so rather than simulating the motion at 100 ms intervals we can simulate it at a smaller interval (\\(t &lt; 100ms\\)) and integrate the photons over the exposure time, 100ms. For fast moving molecules which would resemble comet tails as the intensity (the photons) would leave a trail of photons in its wake over the time the detector is on.</p> <p>SMS_BP allows the user to define the smaller sample time, \\(t\\). For example, in Figure 8 I show the effect of a sample time smaller than the exposure time. For visual aid I have cranked up the mean photons emitted/captured to make the comet tail readily apparent. You can change all these parameters, and we will do this in the final section.</p> <p> Here the motion of a molecule is sampled every 1 ms. The exposure time is 20 ms and there is no interval time between measurements. All three of these parameters ca be user defined! Notice at this particualar frame the PSF of the molecule appears distorted? This is because of motion blur and defocus modelled by SMS_BP. For visual aid I have artificially increased the mean photons emitted/captured for this molecule. The image is slightly ugly due to png compression, but you will get to make your own simulations and appreciate the details.</p> <p> Here the motion of a molecule is sampled every 20 ms. The exposure time is 20 ms and there is no interval time between measurements. Notice there is no PSF deformation in this frame, since the molecule is modelled every 20 ms from the point of view of the simulation nothing occurs in the interval. This is because of there is no modelled motion blur and defocus by SMS_BP. Compared to Figure 8 the only difference is that the over sampling (the \\(t\\) I discuss in the text) is the same as the exposure time in this particular case. For visual aid I have artificially increased the mean photons emitted/captured for this molecule.</p>"},{"location":"User_Guide_MD/#5_working_with_the_code","title":"5. Working With the Code","text":"<p>First things first: use the installing instructions in the main README.md to get the conda environment created and the package installed on your system. This allows you to use the functionality of SMS_BP from anywhere since the path is appended to the main python search path.</p> <p>There are 2 different ways to interact with the code.</p> <ol> <li> <p>In the install we also install a CLI command run_SMS_BP which will     work globally (you do not need to be in the directory of the     project). You will need to provide a config file location to this     command or it will be unhappy with you. You can run run_SMS_BP --help     to see uses.</p> </li> <li> <p>The second is to use the actual code itself through import. We can     do this since we have installed the code as a package.</p> </li> </ol> <p>To keep it simple for now let's focus on the first method. We can run the CLI command: </p> <pre><code>run_SMS_BP config [PATH_TO_CONFIG_FILE]\n</code></pre> <p>This will create a template config file in the current directory if [PATH_TO_CONFIG_FILE] is set to \".\". You can change the . to be a [PATH] to save the file elsewhere. In this newly created template file you will see a nested dictionary with a bunch of parameters and associated values. We will go over each of these and what values are allowable. The document sim_config.md is a text file describing each parameter and the units of each parameter in our main sim_config.json. Use it as a reference if you want to change any of the parameters later on.</p> <p>First of all. Let's change one parameter in the sim_config.json. Find the set of parameters called \\\"Output_Parameters\\\". Inside you will find a parameter called \\\"output_path\\\". Currently it contains a placeholder. Change this to a string which is the absolute path of the place you want SMS_BP to store the final results. So to reiterate change the string \\\"\\&lt;YOUR-PATH-HERE-CAN-BE-ABSOLUTE-OR-RELATIVE&gt;\\\" to the path you want.</p> <p>We can keep the rest of the parameters the same for now and let's just run the simulation. Run using </p> <pre><code>run_SMS_BP runsim sim_config.json\n</code></pre> <p>Once the simulation finishes you will find a new folder created at the path you specified and inside a few files and folders. For now ignore the folders. The .tiff file is the movie of the simulation. params_dump.json is a copy of the sim_config.json used to create this particular simulation, it is also provided as a pickle file. The final file Track_dump.pkl is the true simulation of the underlying motion we did in section 1. This allows you to track the PSFs in the movie and compare back to the true positions of the molecules to see how well you did!</p> <p>Let's redo this but now with the variable oversample_motion_time equal to the exposure_time. Set both to 20 (ms). Notice any difference in the two output movies? This is all I did to create figures 8-9.</p> <p>To do further changes in the simulation I recommend reading the sim_config.md file explaining the role of each parameter in the sim_config.json file. If required I might make tutorials for other features I did not discuss here.</p>"},{"location":"condensate_movement_reference/","title":"Condensate Movement","text":""},{"location":"condensate_movement_reference/#condensate_movement_reference","title":"Condensate Movement Reference","text":"<p>Contains class for storing condensate data. Condensates are defined as spherical always; defined by a center (x,y,z), radius (r), and time (t). The complete description of the condensate at any time (t) is: (x,y,z,r,t).</p>"},{"location":"condensate_movement_reference/#SMS_BP.condensate_movement--usage","title":"Usage:","text":"<pre><code>Initialize the class as follows:\n    condensate = Condensate(**{\n        \"initial_position\":np.array([0, 0, 0]),\n        \"initial_time\":0,\n        \"diffusion_coefficient\":0,\n        \"hurst_exponent\":0,\n        \"units_time\":'ms',\n        \"units_position\":'um',\n        \"condensate_id\":0,\n        \"initial_scale\":0,\n        \"oversample_motion_time\":20,\n    })\nCall the class object as follows to get the position and scale of the condensate at a given time:\n    condensate(times, time_unit) -&gt; dict{\"Position\":np.ndarray, \"Scale\":float}\n</code></pre>"},{"location":"condensate_movement_reference/#SMS_BP.condensate_movement.Condensate","title":"<code>Condensate</code>","text":"<p>Condensate class for storing condensate data.</p>"},{"location":"condensate_movement_reference/#SMS_BP.condensate_movement.Condensate--parameters","title":"Parameters:","text":"<p>initial_position: np.ndarray = np.array([0, 0, 0])     Initial position of the condensate. initial_time: float = 0     Initial time of the condensates. diffusion_coefficient: float = 0     Diffusion coefficient of the condensate. hurst_exponent: float = 0     Hurst exponent of the condensate. units_time: str = 's'     Units of time. Units work as follows: in the class reference frame, start from 0 and iterate by 1 each time.     For a units_time of \"ms\", 1 represents 1ms.     For a units_time of \"s\", 1 represents 1s.     For a units_time of \"20ms\", 1 represents 20ms. units_position: str = 'um'     Units of position. condensate_id: int = 0     ID of the condensate. initial_scale: float = 0     Initial scale of the condensate. cell: BaseCell = None     The cell that contains the condensates. oversample_motion_time: int = None     motion resolution</p> Source code in <code>SMS_BP/condensate_movement.py</code> <pre><code>class Condensate:\n    \"\"\"Condensate class for storing condensate data.\n\n    Parameters:\n    -----------\n    initial_position: np.ndarray = np.array([0, 0, 0])\n        Initial position of the condensate.\n    initial_time: float = 0\n        Initial time of the condensates.\n    diffusion_coefficient: float = 0\n        Diffusion coefficient of the condensate.\n    hurst_exponent: float = 0\n        Hurst exponent of the condensate.\n    units_time: str = 's'\n        Units of time. Units work as follows: in the class reference frame, start from 0 and iterate by 1 each time.\n        For a units_time of \"ms\", 1 represents 1ms.\n        For a units_time of \"s\", 1 represents 1s.\n        For a units_time of \"20ms\", 1 represents 20ms.\n    units_position: str = 'um'\n        Units of position.\n    condensate_id: int = 0\n        ID of the condensate.\n    initial_scale: float = 0\n        Initial scale of the condensate.\n    cell: BaseCell = None\n        The cell that contains the condensates.\n    oversample_motion_time: int = None\n        motion resolution\n\n    \"\"\"\n\n    def __init__(\n        self,\n        initial_position: np.ndarray = np.array([0, 0, 0]),\n        initial_time: int = 0,\n        diffusion_coefficient: float = 0,  # same units as position and time\n        hurst_exponent: float = 0,  # 0&lt;hurst_exponent&lt;1\n        units_time: str = \"ms\",\n        units_position: str = \"um\",\n        condensate_id: int = 0,\n        initial_scale: float = 0,\n        cell: Optional[BaseCell] = None,\n        oversample_motion_time: Optional[int] = None,\n    ):\n        self.initial_position = (\n            np.array(initial_position)\n            if not isinstance(initial_position, np.ndarray)\n            else initial_position\n        )\n        self.initial_time = (\n            int(initial_time) if not isinstance(initial_time, int) else initial_time\n        )\n        self.diffusion_coefficient = (\n            np.array(diffusion_coefficient)\n            if not isinstance(diffusion_coefficient, np.ndarray)\n            else diffusion_coefficient\n        )\n        self.hurst_exponent = (\n            np.array(hurst_exponent)\n            if not isinstance(hurst_exponent, np.ndarray)\n            else hurst_exponent\n        )\n        self.units_time = units_time\n        self.units_position = units_position\n        self.condensate_id = condensate_id\n        self.initial_scale = initial_scale\n\n        self.cell = cell\n        self.dim = self.initial_position.shape[0]\n\n        self.oversample_motion_time = oversample_motion_time\n        # initialize the properties of the condensate\n        self._initialize_properties()\n\n    def _initialize_properties(self) -&gt; None:\n        \"\"\"Initializes the properties of the condensate.\"\"\"\n        self.times = np.array([self.initial_time])\n        self.condensate_positions = np.array([self.initial_position])\n        self.scale = np.array([self.initial_scale])\n\n    @property\n    def times(self) -&gt; np.ndarray:\n        \"\"\"Returns the times of the condensate.\"\"\"\n        return self._times\n\n    @times.setter\n    def times(self, value) -&gt; None:\n        # make sure this is a numpy array\n        if not isinstance(value, np.ndarray):\n            raise TypeError(\"Times must be a numpy array.\")\n        self._times = value\n\n    @property\n    def condensate_positions(self) -&gt; np.ndarray:\n        \"\"\"Returns the positions of the condensate.\"\"\"\n        # make sure this is a numpy array and that it is the same dimension as the initial position\n        return self._condensate_positions\n\n    @condensate_positions.setter\n    def condensate_positions(self, value) -&gt; None:\n        if not isinstance(value, np.ndarray):\n            raise TypeError(\"Condensate positions must be a numpy array.\")\n        if value.shape[1] != self.dim:\n            raise ValueError(\n                \"Condensate positions must be the same dimension as the initial position.\"\n            )\n        self._condensate_positions = value\n\n    @property\n    def scale(self) -&gt; np.ndarray:\n        \"\"\"Returns the scale of the condensate.\"\"\"\n        return self._scale\n\n    @scale.setter\n    def scale(self, value) -&gt; None:\n        self._scale = value\n\n    def add_positions(\n        self, time: np.ndarray, position: np.ndarray, scale: np.ndarray\n    ) -&gt; None:\n        \"\"\"Adds positions to the condensate.\n\n        Parameters:\n        -----------\n        time: np.ndarray\n            Times at which to add positions.\n        position: np.ndarray\n            Positions to add to the condensate.\n        scale: np.ndarray\n            Scale to add to the condensate.\n        \"\"\"\n        self.times = np.append(self.times, time)\n        self.condensate_positions = np.append(\n            self.condensate_positions, position, axis=0\n        )\n        self.scale = np.append(self.scale, scale)\n\n    @cache\n    def __call__(self, time: int, time_unit: str) -&gt; dict:\n        \"\"\"Returns the position and scale of the condensate at a given time.\n\n        Parameters:\n        -----------\n        time: float\n            Time at which to return the position of the condensate. User needs to convert to the reference frame of the condensate class.\n        time_unit: str\n            Units of time.\n            Just to make sure the user is aware of the conversion they need to do to get into the reference frame of the condensate class.\n\n        Returns:\n        --------\n        Dict of the position and scale of the condensate at the given time.\n            Keys:\n                Position: np.ndarray\n                    Position of the condensate at the given time.\n                Scale: float\n                    Scale of the condensate at the given time.\n        \"\"\"\n        if time_unit != self.units_time:\n            # raise error that you need to ask for the time units in the condensates reference frame\n            raise ValueError(\"Time units do not match to the condensate.\")\n        # check if the _condensate_positions exists\n        if not hasattr(self, \"_condensate_positions\"):\n            # if it doesn't then we need to generate the condensate positions\n            self.times = np.array([self.initial_time])\n            self.condensate_positions = np.array([self.initial_position])\n            self.scale = np.array([self.initial_scale])\n        # if the time larger than the last time in the condensate_positions then we need to generate more positions\n        if time &gt; self.times[-1]:\n            self.generate_condensate_positions(time)\n\n        return {\n            \"Position\": self.condensate_positions[self.times == time][0],\n            \"Scale\": self.scale[self.times == time][0],\n        }\n\n    def generate_condensate_positions(self, time: int) -&gt; None:\n        \"\"\"Generates the condensate positions up to a given time.\n\n        Parameters:\n        -----------\n        time: int\n            Time up to which to generate the condensate positions.\n        \"\"\"\n        # find the time difference\n        time_difference = time - self.times[-1]\n        # make a time array starting from the last time +1 and goin to the time inclusive\n        time_array = np.arange(\n            self.times[-1] + 1,\n            time + 1,\n        )\n\n        track_generator = Track_generator(\n            cell=self.cell,\n            total_time=time,\n            oversample_motion_time=self.oversample_motion_time,\n        )\n        track = track_generator.track_generation_no_transition(\n            diffusion_coefficient=self.diffusion_coefficient,\n            hurst_exponent=self.hurst_exponent,\n            track_length=int(time_difference),\n            initials=self.condensate_positions[-1],\n            start_time=self.times[-1],\n        )\n        track_xyz = track[\"xy\"][:]\n        # take all the x,y,z\n        track_xyz = track_xyz[:, :]\n        # get the scale for the time array and positions\n        scales = self.calculate_scale(time_array, track_xyz)\n        # add the positions to the condensate_positions\n        self.add_positions(time_array, track_xyz, scales)\n\n    def calculate_scale(self, time: np.ndarray, position: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Calculates the scale of the condensate at a given time.\n\n        Parameters:\n        -----------\n        time: np.ndarray\n            Times at which to calculate the scale.\n        position: np.ndarray\n            Positions at which to calculate the scale.\n        \"\"\"\n        # find the last scale in the scale array\n        last_scale = self.scale[-1]\n        # make array of length time with the last scale\n        scale = np.full(time.shape, last_scale)\n        return scale\n</code></pre>"},{"location":"condensate_movement_reference/#SMS_BP.condensate_movement.Condensate.condensate_positions","title":"<code>condensate_positions</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the positions of the condensate.</p>"},{"location":"condensate_movement_reference/#SMS_BP.condensate_movement.Condensate.scale","title":"<code>scale</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the scale of the condensate.</p>"},{"location":"condensate_movement_reference/#SMS_BP.condensate_movement.Condensate.times","title":"<code>times</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the times of the condensate.</p>"},{"location":"condensate_movement_reference/#SMS_BP.condensate_movement.Condensate.__call__","title":"<code>__call__(time, time_unit)</code>","text":"<p>Returns the position and scale of the condensate at a given time.</p>"},{"location":"condensate_movement_reference/#SMS_BP.condensate_movement.Condensate.__call__--parameters","title":"Parameters:","text":"<p>time: float     Time at which to return the position of the condensate. User needs to convert to the reference frame of the condensate class. time_unit: str     Units of time.     Just to make sure the user is aware of the conversion they need to do to get into the reference frame of the condensate class.</p>"},{"location":"condensate_movement_reference/#SMS_BP.condensate_movement.Condensate.__call__--returns","title":"Returns:","text":"<p>Dict of the position and scale of the condensate at the given time.     Keys:         Position: np.ndarray             Position of the condensate at the given time.         Scale: float             Scale of the condensate at the given time.</p> Source code in <code>SMS_BP/condensate_movement.py</code> <pre><code>@cache\ndef __call__(self, time: int, time_unit: str) -&gt; dict:\n    \"\"\"Returns the position and scale of the condensate at a given time.\n\n    Parameters:\n    -----------\n    time: float\n        Time at which to return the position of the condensate. User needs to convert to the reference frame of the condensate class.\n    time_unit: str\n        Units of time.\n        Just to make sure the user is aware of the conversion they need to do to get into the reference frame of the condensate class.\n\n    Returns:\n    --------\n    Dict of the position and scale of the condensate at the given time.\n        Keys:\n            Position: np.ndarray\n                Position of the condensate at the given time.\n            Scale: float\n                Scale of the condensate at the given time.\n    \"\"\"\n    if time_unit != self.units_time:\n        # raise error that you need to ask for the time units in the condensates reference frame\n        raise ValueError(\"Time units do not match to the condensate.\")\n    # check if the _condensate_positions exists\n    if not hasattr(self, \"_condensate_positions\"):\n        # if it doesn't then we need to generate the condensate positions\n        self.times = np.array([self.initial_time])\n        self.condensate_positions = np.array([self.initial_position])\n        self.scale = np.array([self.initial_scale])\n    # if the time larger than the last time in the condensate_positions then we need to generate more positions\n    if time &gt; self.times[-1]:\n        self.generate_condensate_positions(time)\n\n    return {\n        \"Position\": self.condensate_positions[self.times == time][0],\n        \"Scale\": self.scale[self.times == time][0],\n    }\n</code></pre>"},{"location":"condensate_movement_reference/#SMS_BP.condensate_movement.Condensate.add_positions","title":"<code>add_positions(time, position, scale)</code>","text":"<p>Adds positions to the condensate.</p>"},{"location":"condensate_movement_reference/#SMS_BP.condensate_movement.Condensate.add_positions--parameters","title":"Parameters:","text":"<p>time: np.ndarray     Times at which to add positions. position: np.ndarray     Positions to add to the condensate. scale: np.ndarray     Scale to add to the condensate.</p> Source code in <code>SMS_BP/condensate_movement.py</code> <pre><code>def add_positions(\n    self, time: np.ndarray, position: np.ndarray, scale: np.ndarray\n) -&gt; None:\n    \"\"\"Adds positions to the condensate.\n\n    Parameters:\n    -----------\n    time: np.ndarray\n        Times at which to add positions.\n    position: np.ndarray\n        Positions to add to the condensate.\n    scale: np.ndarray\n        Scale to add to the condensate.\n    \"\"\"\n    self.times = np.append(self.times, time)\n    self.condensate_positions = np.append(\n        self.condensate_positions, position, axis=0\n    )\n    self.scale = np.append(self.scale, scale)\n</code></pre>"},{"location":"condensate_movement_reference/#SMS_BP.condensate_movement.Condensate.calculate_scale","title":"<code>calculate_scale(time, position)</code>","text":"<p>Calculates the scale of the condensate at a given time.</p>"},{"location":"condensate_movement_reference/#SMS_BP.condensate_movement.Condensate.calculate_scale--parameters","title":"Parameters:","text":"<p>time: np.ndarray     Times at which to calculate the scale. position: np.ndarray     Positions at which to calculate the scale.</p> Source code in <code>SMS_BP/condensate_movement.py</code> <pre><code>def calculate_scale(self, time: np.ndarray, position: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Calculates the scale of the condensate at a given time.\n\n    Parameters:\n    -----------\n    time: np.ndarray\n        Times at which to calculate the scale.\n    position: np.ndarray\n        Positions at which to calculate the scale.\n    \"\"\"\n    # find the last scale in the scale array\n    last_scale = self.scale[-1]\n    # make array of length time with the last scale\n    scale = np.full(time.shape, last_scale)\n    return scale\n</code></pre>"},{"location":"condensate_movement_reference/#SMS_BP.condensate_movement.Condensate.generate_condensate_positions","title":"<code>generate_condensate_positions(time)</code>","text":"<p>Generates the condensate positions up to a given time.</p>"},{"location":"condensate_movement_reference/#SMS_BP.condensate_movement.Condensate.generate_condensate_positions--parameters","title":"Parameters:","text":"<p>time: int     Time up to which to generate the condensate positions.</p> Source code in <code>SMS_BP/condensate_movement.py</code> <pre><code>def generate_condensate_positions(self, time: int) -&gt; None:\n    \"\"\"Generates the condensate positions up to a given time.\n\n    Parameters:\n    -----------\n    time: int\n        Time up to which to generate the condensate positions.\n    \"\"\"\n    # find the time difference\n    time_difference = time - self.times[-1]\n    # make a time array starting from the last time +1 and goin to the time inclusive\n    time_array = np.arange(\n        self.times[-1] + 1,\n        time + 1,\n    )\n\n    track_generator = Track_generator(\n        cell=self.cell,\n        total_time=time,\n        oversample_motion_time=self.oversample_motion_time,\n    )\n    track = track_generator.track_generation_no_transition(\n        diffusion_coefficient=self.diffusion_coefficient,\n        hurst_exponent=self.hurst_exponent,\n        track_length=int(time_difference),\n        initials=self.condensate_positions[-1],\n        start_time=self.times[-1],\n    )\n    track_xyz = track[\"xy\"][:]\n    # take all the x,y,z\n    track_xyz = track_xyz[:, :]\n    # get the scale for the time array and positions\n    scales = self.calculate_scale(time_array, track_xyz)\n    # add the positions to the condensate_positions\n    self.add_positions(time_array, track_xyz, scales)\n</code></pre>"},{"location":"condensate_movement_reference/#SMS_BP.condensate_movement.create_condensate_dict","title":"<code>create_condensate_dict(initial_centers, initial_scale, diffusion_coefficient, hurst_exponent, cell, **kwargs)</code>","text":"<p>Creates a dictionary of condensates for simulation.</p>"},{"location":"condensate_movement_reference/#SMS_BP.condensate_movement.create_condensate_dict--parameters","title":"Parameters:","text":"<p>initial_centers : np.ndarray     Array of shape (num_condensates, 2) representing the initial centers of the condensates. initial_scale : np.ndarray     Array of shape (num_condensates, 2) representing the initial scales of the condensates. diffusion_coefficient : np.ndarray     Array of shape (num_condensates, 2) representing the diffusion coefficients of the condensates. hurst_exponent : np.ndarray     Array of shape (num_condensates, 2) representing the Hurst exponents of the condensates. cell : BaseCell     The cell that contains the condensates. **kwargs : dict     Additional arguments passed to <code>Condensate</code> class.</p> <pre><code>oversample_motion_time : int\n    smallest time unit for motion (time resolution for motion) (ms)\n</code></pre>"},{"location":"condensate_movement_reference/#SMS_BP.condensate_movement.create_condensate_dict--returns","title":"Returns:","text":"<p>dict     A dictionary of <code>Condensate</code> objects with keys as condensate IDs.</p> Source code in <code>SMS_BP/condensate_movement.py</code> <pre><code>def create_condensate_dict(\n    initial_centers: np.ndarray,\n    initial_scale: np.ndarray,\n    diffusion_coefficient: np.ndarray,\n    hurst_exponent: np.ndarray,\n    cell: BaseCell,\n    **kwargs,\n) -&gt; dict:\n    \"\"\"\n    Creates a dictionary of condensates for simulation.\n\n    Parameters:\n    -----------\n    initial_centers : np.ndarray\n        Array of shape (num_condensates, 2) representing the initial centers of the condensates.\n    initial_scale : np.ndarray\n        Array of shape (num_condensates, 2) representing the initial scales of the condensates.\n    diffusion_coefficient : np.ndarray\n        Array of shape (num_condensates, 2) representing the diffusion coefficients of the condensates.\n    hurst_exponent : np.ndarray\n        Array of shape (num_condensates, 2) representing the Hurst exponents of the condensates.\n    cell : BaseCell\n        The cell that contains the condensates.\n    **kwargs : dict\n        Additional arguments passed to `Condensate` class.\n\n        oversample_motion_time : int\n            smallest time unit for motion (time resolution for motion) (ms)\n\n    Returns:\n    --------\n    dict\n        A dictionary of `Condensate` objects with keys as condensate IDs.\n    \"\"\"\n    # check the length of diffusion_coefficient to find the number of condensates\n    num_condensates = len(diffusion_coefficient)\n    condensates = {}\n    units_time = kwargs.get(\"units_time\", [\"ms\"] * num_condensates)\n    for i in range(num_condensates):\n        condensates[str(i)] = Condensate(\n            initial_position=initial_centers[i],\n            initial_scale=initial_scale[i],\n            diffusion_coefficient=diffusion_coefficient[i],\n            hurst_exponent=hurst_exponent[i],\n            condensate_id=int(str(i)),\n            units_time=units_time[i],\n            cell=cell,\n            oversample_motion_time=kwargs.get(\"oversample_motion_time\", None),\n        )\n    return condensates\n</code></pre>"},{"location":"config_schema_reference/","title":"Config Schema","text":""},{"location":"config_schema_reference/#config_schema_reference","title":"Config Schema Reference","text":""},{"location":"config_schema_reference/#SMS_BP.config_schema--simulation_configuration_module","title":"Simulation Configuration Module","text":"<p>This module defines the structure and parameters required for simulating cell behavior, diffusion tracks, and condensate dynamics within a spatial environment. The simulation configuration is described both in terms of a JSON schema and Python dataclasses, which are used to manage and validate the input parameters for simulations. The parameters are grouped into different categories like <code>Cell_Parameters</code>, <code>Track_Parameters</code>, <code>Global_Parameters</code>, <code>Condensate_Parameters</code>, and <code>Output_Parameters</code>.</p> <p>The simulation configuration allows for customizing aspects like track diffusion, Hurst exponents, condensate properties, and camera settings. The module ensures that the correct units (e.g., space, time, intensity, diffusion) are used consistently throughout the simulation, helping to provide accurate modeling of physical phenomena.</p> <p>The module follows the structure outlined in the corresponding JSON schema (<code>sim_config.json</code>), providing an intuitive and structured way to organize simulation parameters.</p>"},{"location":"config_schema_reference/#SMS_BP.config_schema--configuration_parameters","title":"Configuration Parameters","text":"<p>The configuration is composed of multiple groups of parameters, each represented by a Python dataclass and organized into the following sections:</p> <ol> <li> <p>version: <code>str</code></p> <ul> <li>The version of the simulation configuration file.</li> </ul> </li> <li> <p>length_unit: <code>str</code></p> <ul> <li>Unit for length in the simulation (e.g., nm, um, mm).</li> </ul> </li> <li> <p>space_unit: <code>str</code></p> <ul> <li>Unit for space in the simulation (e.g., pixel).</li> </ul> </li> <li> <p>time_unit: <code>str</code></p> <ul> <li>Unit for time in the simulation (e.g., s, ms, us).</li> </ul> </li> <li> <p>intensity_unit: <code>str</code></p> <ul> <li>Unit for intensity in the simulation (AUD only supported).</li> </ul> </li> <li> <p>diffusion_unit: <code>str</code></p> <ul> <li>Unit for diffusion in the simulation (e.g., um\u00b2/s, mm\u00b2/s).</li> </ul> </li> </ol>"},{"location":"config_schema_reference/#SMS_BP.config_schema--cell_parameters","title":"Cell Parameters","text":""},{"location":"config_schema_reference/#SMS_BP.config_schema--cell_type","title":"<code>cell_type</code>","text":"<ul> <li>Type: Union[str, CellType]</li> <li>Description: Defines the type of the cell to simulate.</li> <li>Supported: RectangularCell, SphericalCell, OvoidCell, RodCell, BuddingCell</li> </ul>"},{"location":"config_schema_reference/#SMS_BP.config_schema--params","title":"<code>params</code>","text":"<ul> <li>Type: dictionary of parameter names (String) and values (Any)</li> <li>Description: Values for the cell_type specified above. The following the general structure:</li> </ul> <pre><code># SphericalCell\nparams = {\n    \"center\": [0, 0, 0],   # 3D center coordinates\n    \"radius\": 10.0         # Radius of sphere\n}\n</code></pre> <pre><code># RodCell\nparams = {\n    \"center\": [0, 0, 0],       # 3D center coordinates\n    \"direction\": [0, 0, 1],    # Direction vector (will be normalized)\n    \"height\": 20.0,            # Length of the rod\n    \"radius\": 5.0              # Radius of the rod\n}\n</code></pre> <pre><code># RectangularCell\nparams = {\n    \"bounds\": [-10, 10, -10, 10, -10, 10]  # [xmin, xmax, ymin, ymax, zmin, zmax]\n}\n</code></pre> <pre><code># OvoidCell\nparams = {\n    \"center\": [0, 0, 0],       # 3D center coordinates\n    \"xradius\": 10.0,           # Radius in x-direction\n    \"yradius\": 15.0,           # Radius in y-direction\n    \"zradius\": 20.0            # Radius in z-direction\n}\n</code></pre> <ul> <li>number_of_cells: <code>int</code><ul> <li>Number of cells to simulate.</li> </ul> </li> </ul>"},{"location":"config_schema_reference/#SMS_BP.config_schema--track_parameters","title":"Track Parameters","text":"<ul> <li>num_tracks: <code>int</code><ul> <li>Number of tracks to simulate.</li> </ul> </li> <li>track_type: <code>str</code><ul> <li>Type of track to simulate (e.g., \"fbm\" for fractional Brownian motion).</li> </ul> </li> <li>track_length_mean: <code>int</code><ul> <li>Mean length of the track (in frames).</li> </ul> </li> <li>track_distribution: <code>str</code><ul> <li>Distribution type for track lengths (e.g., \"exponential\", \"constant\").</li> </ul> </li> <li>diffusion_coefficient: <code>List[float]</code><ul> <li>List of diffusion coefficients (in units of <code>diffusion_unit</code>).</li> </ul> </li> <li>diffusion_track_amount: <code>List[float]</code><ul> <li>Probabilities for each diffusion coefficient (must sum to 1.0).</li> </ul> </li> <li>hurst_exponent: <code>List[float]</code><ul> <li>List of Hurst exponents, defining the track behavior.</li> </ul> </li> <li>hurst_track_amount: <code>List[float]</code><ul> <li>Probabilities for each Hurst exponent (must sum to 1.0).</li> </ul> </li> <li>allow_transition_probability: <code>bool</code><ul> <li>Whether to allow transitions between different diffusion coefficients and Hurst exponents.</li> </ul> </li> <li>transition_matrix_time_step: <code>int</code><ul> <li>Time step for the transition matrices (in <code>time_unit</code>).</li> </ul> </li> <li>diffusion_transition_matrix: <code>List[List[float]]</code><ul> <li>Transition matrix for different diffusion coefficients (rows must sum to 1.0).</li> </ul> </li> <li>hurst_transition_matrix: <code>List[List[float]]</code><ul> <li>Transition matrix for different Hurst exponents (rows must sum to 1.0).</li> </ul> </li> <li>state_probability_diffusion: <code>List[float]</code><ul> <li>Initial probabilities for each diffusion coefficient state.</li> </ul> </li> <li>state_probability_hurst: <code>List[float]</code><ul> <li>Initial probabilities for each Hurst exponent state.</li> </ul> </li> </ul>"},{"location":"config_schema_reference/#SMS_BP.config_schema--global_parameters","title":"Global Parameters","text":"<ul> <li>field_of_view_dim: <code>List[float]</code><ul> <li>Field of view dimensions in pixels.</li> </ul> </li> <li>frame_count: <code>int</code><ul> <li>Total number of frames in the simulation.</li> </ul> </li> <li>exposure_time: <code>float</code><ul> <li>Exposure time of the camera (in <code>time_unit</code>).</li> </ul> </li> <li>interval_time: <code>float</code><ul> <li>Time between frames when the camera is on (in <code>time_unit</code>).</li> </ul> </li> <li>oversample_motion_time: <code>float</code><ul> <li>Time for oversampling motion to simulate motion blur.</li> <li>If equal to <code>frame_time</code> and <code>exposure_time</code>, there is no motion blur.</li> </ul> </li> <li>pixel_size: <code>float</code><ul> <li>Size of each pixel (in <code>length_unit</code>).</li> </ul> </li> <li>axial_detection_range: <code>float</code><ul> <li>Range for detecting molecule excitation in the z-direction (in <code>length_unit</code>).</li> </ul> </li> <li>base_noise: <code>float</code><ul> <li>Base noise of the camera (in <code>intensity_unit</code>).</li> </ul> </li> <li>point_intensity: <code>float</code><ul> <li>Intensity of a single molecule excitation (in <code>intensity_unit</code>).</li> </ul> </li> <li>psf_sigma: <code>float</code><ul> <li>Point Spread Function (PSF) sigma (in <code>length_unit</code>).</li> </ul> </li> <li>axial_function: <code>str</code><ul> <li>Function for intensity change with z (e.g., \"exponential\", \"ones\" for no effect).</li> </ul> </li> </ul>"},{"location":"config_schema_reference/#SMS_BP.config_schema--condensate_parameters","title":"Condensate Parameters","text":"<ul> <li>initial_centers: <code>List[List[float]]</code><ul> <li>Initial centers of the condensates, with [x, y, z] coordinates per row.</li> </ul> </li> <li>initial_scale: <code>List[float]</code><ul> <li>Initial radius of each condensate (in <code>space_unit</code>).</li> </ul> </li> <li>diffusion_coefficient: <code>List[float]</code><ul> <li>Diffusion coefficients for each condensate (in <code>diffusion_unit</code>).</li> </ul> </li> <li>hurst_exponent: <code>List[float]</code><ul> <li>Hurst exponents for each condensate.</li> </ul> </li> <li>density_dif: <code>float</code><ul> <li>Density difference between the condensates and the rest of the cell.</li> </ul> </li> </ul>"},{"location":"config_schema_reference/#SMS_BP.config_schema--output_parameters","title":"Output Parameters","text":"<ul> <li>output_path: <code>str</code><ul> <li>Path to the directory where the output will be saved.</li> </ul> </li> <li>output_name: <code>str</code><ul> <li>Name of the output file.</li> </ul> </li> <li>subsegment_type: <code>str</code><ul> <li>Function for projecting data across subsegments (e.g., \"mean\", \"max\", \"sum\").</li> </ul> </li> <li>subsegment_number: <code>int</code><ul> <li>Number of subsegments to divide the simulation frames into. The total number of frames must be divisible by the subsegment number.</li> </ul> </li> </ul>"},{"location":"config_schema_reference/#SMS_BP.config_schema--dataclasses","title":"Dataclasses","text":"<p>This module defines Python dataclasses to represent each section of the simulation configuration. The dataclasses allow for structured data management, type-checking, and easy manipulation of simulation parameters.</p> <ol> <li> <p>CellParameters:</p> <ul> <li>Stores the cell space, axial radius, and number of cells.</li> </ul> </li> <li> <p>TrackParameters:</p> <ul> <li>Stores track-related parameters such as number of tracks, track length, diffusion coefficients, and Hurst exponents.</li> </ul> </li> <li> <p>GlobalParameters:</p> <ul> <li>Stores global simulation settings such as field of view, frame count, and camera parameters.</li> </ul> </li> <li> <p>CondensateParameters:</p> <ul> <li>Stores parameters related to condensates, including their initial centers, scales, and diffusion coefficients.</li> </ul> </li> <li> <p>OutputParameters:</p> <ul> <li>Stores output-related settings such as file path, file name, and subsegment configurations.</li> </ul> </li> <li> <p>SimulationConfig:</p> <ul> <li>The main class that contains all the parameters for the simulation. Inherits from a base class to facilitate   conversion of lists to NumPy arrays for efficient mathematical operations.</li> </ul> </li> </ol>"},{"location":"config_schema_reference/#SMS_BP.config_schema.ABCConfig","title":"<code>ABCConfig</code>  <code>dataclass</code>","text":"Source code in <code>SMS_BP/config_schema.py</code> <pre><code>@dataclass\nclass ABCConfig:\n    def make_array(self):\n        \"\"\"\n        Recursively converts all list attributes to numpy arrays, including nested dataclasses.\n        \"\"\"\n\n        def _convert(obj: Any):\n            if isinstance(obj, list):\n                return np.array(obj)\n            elif is_dataclass(obj):\n                # Traverse nested dataclass\n                for field in fields(obj):\n                    value = getattr(obj, field.name)\n                    setattr(obj, field.name, _convert(value))\n            return obj\n\n        # Apply conversion to the main dataclass\n        for field in fields(self):\n            value = getattr(self, field.name)\n            setattr(self, field.name, _convert(value))\n</code></pre>"},{"location":"config_schema_reference/#SMS_BP.config_schema.ABCConfig.make_array","title":"<code>make_array()</code>","text":"<p>Recursively converts all list attributes to numpy arrays, including nested dataclasses.</p> Source code in <code>SMS_BP/config_schema.py</code> <pre><code>def make_array(self):\n    \"\"\"\n    Recursively converts all list attributes to numpy arrays, including nested dataclasses.\n    \"\"\"\n\n    def _convert(obj: Any):\n        if isinstance(obj, list):\n            return np.array(obj)\n        elif is_dataclass(obj):\n            # Traverse nested dataclass\n            for field in fields(obj):\n                value = getattr(obj, field.name)\n                setattr(obj, field.name, _convert(value))\n        return obj\n\n    # Apply conversion to the main dataclass\n    for field in fields(self):\n        value = getattr(self, field.name)\n        setattr(self, field.name, _convert(value))\n</code></pre>"},{"location":"errors_reference/","title":"Errors","text":""},{"location":"errors_reference/#errors_schema","title":"Errors Schema","text":""},{"location":"errors_reference/#SMS_BP.errors.ConfigConversionError","title":"<code>ConfigConversionError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised for errors in the configuration conversion process.</p> Source code in <code>SMS_BP/errors.py</code> <pre><code>class ConfigConversionError(Exception):\n    \"\"\"Exception raised for errors in the configuration conversion process.\"\"\"\n\n    pass\n</code></pre>"},{"location":"errors_reference/#SMS_BP.errors.ConfigValidationError","title":"<code>ConfigValidationError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised for errors in the configuration validation.</p> Source code in <code>SMS_BP/errors.py</code> <pre><code>class ConfigValidationError(Exception):\n    \"\"\"Exception raised for errors in the configuration validation.\"\"\"\n\n    pass\n</code></pre>"},{"location":"errors_reference/#SMS_BP.errors.DiffusionHighError","title":"<code>DiffusionHighError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when the diffusion value is too high for the space limit</p> Source code in <code>SMS_BP/errors.py</code> <pre><code>class DiffusionHighError(Exception):\n    \"\"\"Raised when the diffusion value is too high for the space limit\"\"\"\n\n    pass\n</code></pre>"},{"location":"errors_reference/#SMS_BP.errors.HurstHighError","title":"<code>HurstHighError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when the Hurst value is too high for the space limit</p> Source code in <code>SMS_BP/errors.py</code> <pre><code>class HurstHighError(Exception):\n    \"\"\"Raised when the Hurst value is too high for the space limit\"\"\"\n\n    pass\n</code></pre>"},{"location":"errors_reference/#SMS_BP.errors.HurstValueError","title":"<code>HurstValueError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when the Hurst value is not within the range (0, 1)</p> Source code in <code>SMS_BP/errors.py</code> <pre><code>class HurstValueError(Exception):\n    \"\"\"Raised when the Hurst value is not within the range (0, 1)\"\"\"\n\n    pass\n</code></pre>"},{"location":"errors_reference/#SMS_BP.errors.SpaceLimitError","title":"<code>SpaceLimitError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when the space limit is not within the range (-inf, inf)</p> Source code in <code>SMS_BP/errors.py</code> <pre><code>class SpaceLimitError(Exception):\n    \"\"\"Raised when the space limit is not within the range (-inf, inf)\"\"\"\n\n    pass\n</code></pre>"},{"location":"json_validator_converter_reference/","title":"JSON Validator Converter","text":""},{"location":"json_validator_converter_reference/#json_validator_converter_reference","title":"JSON Validator Converter Reference","text":""},{"location":"json_validator_converter_reference/#SMS_BP.json_validator_converter.json_to_dataclass","title":"<code>json_to_dataclass(json_data)</code>","text":"<p>Converts a validated JSON object into a <code>SimulationConfig</code> dataclass.</p>"},{"location":"json_validator_converter_reference/#SMS_BP.json_validator_converter.json_to_dataclass--parameters","title":"Parameters:","text":"<p>json_data : dict     The validated JSON data representing the simulation configuration.</p>"},{"location":"json_validator_converter_reference/#SMS_BP.json_validator_converter.json_to_dataclass--returns","title":"Returns:","text":"<p>SimulationConfig     A <code>SimulationConfig</code> object populated with data from the JSON input.</p>"},{"location":"json_validator_converter_reference/#SMS_BP.json_validator_converter.json_to_dataclass--raises","title":"Raises:","text":"<p>ConfigConversionError     If required keys are missing or if there is a type mismatch during conversion.</p> Source code in <code>SMS_BP/json_validator_converter.py</code> <pre><code>def json_to_dataclass(json_data: dict) -&gt; SimulationConfig:\n    \"\"\"\n    Converts a validated JSON object into a `SimulationConfig` dataclass.\n\n    Parameters:\n    -----------\n    json_data : dict\n        The validated JSON data representing the simulation configuration.\n\n    Returns:\n    --------\n    SimulationConfig\n        A `SimulationConfig` object populated with data from the JSON input.\n\n    Raises:\n    -------\n    ConfigConversionError\n        If required keys are missing or if there is a type mismatch during conversion.\n    \"\"\"\n    try:\n        return SimulationConfig(\n            version=json_data[\"version\"],\n            length_unit=json_data[\"length_unit\"],\n            space_unit=json_data[\"space_unit\"],\n            time_unit=json_data[\"time_unit\"],\n            intensity_unit=json_data[\"intensity_unit\"],\n            diffusion_unit=json_data[\"diffusion_unit\"],\n            Cell_Parameters=CellParameters(**json_data[\"Cell_Parameters\"]),\n            Track_Parameters=TrackParameters(**json_data[\"Track_Parameters\"]),\n            Global_Parameters=GlobalParameters(**json_data[\"Global_Parameters\"]),\n            Condensate_Parameters=CondensateParameters(\n                **json_data[\"Condensate_Parameters\"]\n            ),\n            Output_Parameters=OutputParameters(**json_data[\"Output_Parameters\"]),\n        )\n    except KeyError as e:\n        raise ConfigConversionError(f\"Missing key in JSON data: {e}\")\n    except TypeError as e:\n        raise ConfigConversionError(f\"Type mismatch during conversion: {e}\")\n</code></pre>"},{"location":"json_validator_converter_reference/#SMS_BP.json_validator_converter.load_validate_and_convert","title":"<code>load_validate_and_convert(file_path)</code>","text":"<p>Loads, validates, and converts a simulation configuration file to a <code>SimulationConfig</code> dataclass.</p> <p>This function reads the JSON configuration file, validates its structure against the schema, and then converts it to a <code>SimulationConfig</code> dataclass.</p>"},{"location":"json_validator_converter_reference/#SMS_BP.json_validator_converter.load_validate_and_convert--parameters","title":"Parameters:","text":"<p>file_path : str     Path to the JSON file containing the simulation configuration.</p>"},{"location":"json_validator_converter_reference/#SMS_BP.json_validator_converter.load_validate_and_convert--returns","title":"Returns:","text":"<p>SimulationConfig     A <code>SimulationConfig</code> object populated with the data from the file.</p>"},{"location":"json_validator_converter_reference/#SMS_BP.json_validator_converter.load_validate_and_convert--raises","title":"Raises:","text":"<p>ConfigValidationError     If the JSON file is invalid or cannot be loaded. ConfigConversionError     If an error occurs during the conversion to the dataclass.</p> Source code in <code>SMS_BP/json_validator_converter.py</code> <pre><code>def load_validate_and_convert(file_path: str) -&gt; SimulationConfig:\n    \"\"\"\n    Loads, validates, and converts a simulation configuration file to a `SimulationConfig` dataclass.\n\n    This function reads the JSON configuration file, validates its structure against the schema,\n    and then converts it to a `SimulationConfig` dataclass.\n\n    Parameters:\n    -----------\n    file_path : str\n        Path to the JSON file containing the simulation configuration.\n\n    Returns:\n    --------\n    SimulationConfig\n        A `SimulationConfig` object populated with the data from the file.\n\n    Raises:\n    -------\n    ConfigValidationError\n        If the JSON file is invalid or cannot be loaded.\n    ConfigConversionError\n        If an error occurs during the conversion to the dataclass.\n    \"\"\"\n    try:\n        with open(file_path, \"r\") as file:\n            json_data = json.load(file)\n\n        validate_json(json_data)\n        config = json_to_dataclass(json_data)\n        return config\n    except json.JSONDecodeError as e:\n        raise ConfigValidationError(f\"Error decoding JSON: {e}\")\n    except FileNotFoundError as e:\n        raise ConfigValidationError(f\"File not found: {e}\")\n</code></pre>"},{"location":"json_validator_converter_reference/#SMS_BP.json_validator_converter.validate_and_convert","title":"<code>validate_and_convert(loaded_json)</code>","text":"<p>Validates and converts an in-memory JSON object to a <code>SimulationConfig</code> dataclass.</p> <p>This function is useful when the JSON data is already loaded into memory, bypassing the need to read from a file.</p>"},{"location":"json_validator_converter_reference/#SMS_BP.json_validator_converter.validate_and_convert--parameters","title":"Parameters:","text":"<p>loaded_json : dict     The JSON data to validate and convert.</p>"},{"location":"json_validator_converter_reference/#SMS_BP.json_validator_converter.validate_and_convert--returns","title":"Returns:","text":"<p>SimulationConfig     A <code>SimulationConfig</code> object populated with data from the JSON input.</p>"},{"location":"json_validator_converter_reference/#SMS_BP.json_validator_converter.validate_and_convert--raises","title":"Raises:","text":"<p>ConfigValidationError     If the JSON data does not comply with the schema. ConfigConversionError     If there is a type mismatch or a key is missing during conversion.</p> Source code in <code>SMS_BP/json_validator_converter.py</code> <pre><code>def validate_and_convert(loaded_json: dict) -&gt; SimulationConfig:\n    \"\"\"\n    Validates and converts an in-memory JSON object to a `SimulationConfig` dataclass.\n\n    This function is useful when the JSON data is already loaded into memory, bypassing the need to\n    read from a file.\n\n    Parameters:\n    -----------\n    loaded_json : dict\n        The JSON data to validate and convert.\n\n    Returns:\n    --------\n    SimulationConfig\n        A `SimulationConfig` object populated with data from the JSON input.\n\n    Raises:\n    -------\n    ConfigValidationError\n        If the JSON data does not comply with the schema.\n    ConfigConversionError\n        If there is a type mismatch or a key is missing during conversion.\n    \"\"\"\n    try:\n        validate_json(loaded_json)\n        return json_to_dataclass(loaded_json)\n    except ValidationError as e:\n        raise ConfigValidationError(f\"JSON validation error: {e}\")\n    except TypeError as e:\n        raise ConfigConversionError(f\"Type mismatch during conversion: {e}\")\n    except Exception as e:\n        raise ConfigValidationError(f\"An unexpected error occurred: {e}\")\n</code></pre>"},{"location":"json_validator_converter_reference/#SMS_BP.json_validator_converter.validate_json","title":"<code>validate_json(json_data)</code>","text":"<p>Validates a JSON object against the defined simulation schema.</p>"},{"location":"json_validator_converter_reference/#SMS_BP.json_validator_converter.validate_json--parameters","title":"Parameters:","text":"<p>json_data : dict     The JSON data to be validated.</p>"},{"location":"json_validator_converter_reference/#SMS_BP.json_validator_converter.validate_json--returns","title":"Returns:","text":"<p>bool     Returns <code>True</code> if the JSON data is valid.</p>"},{"location":"json_validator_converter_reference/#SMS_BP.json_validator_converter.validate_json--raises","title":"Raises:","text":"<p>ConfigValidationError     If the JSON data does not comply with the schema.</p> Source code in <code>SMS_BP/json_validator_converter.py</code> <pre><code>def validate_json(json_data: dict) -&gt; bool:\n    \"\"\"\n    Validates a JSON object against the defined simulation schema.\n\n    Parameters:\n    -----------\n    json_data : dict\n        The JSON data to be validated.\n\n    Returns:\n    --------\n    bool\n        Returns `True` if the JSON data is valid.\n\n    Raises:\n    -------\n    ConfigValidationError\n        If the JSON data does not comply with the schema.\n    \"\"\"\n    try:\n        validate(instance=json_data, schema=schema)\n        return True\n    except ValidationError as e:\n        raise ConfigValidationError(f\"JSON validation error: {e}\")\n</code></pre>"},{"location":"license/","title":"License","text":""},{"location":"license/#license","title":"License","text":"<p>Copyright (c) [2024] Baljyot Singh Parmar [All rights reserved].</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <p>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. THIS SOFTWARE IS PROVIDED BY Baljyot Singh Parmar \u201cAS IS\u201d AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL [Baljyot Singh Parmar] BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"probability_functions_reference/","title":"Probability Functions","text":""},{"location":"probability_functions_reference/#sms_bpprobability_functions","title":"SMS_BP.probability_functions","text":""},{"location":"probability_functions_reference/#SMS_BP.probability_functions--top_hat_probability_function_module","title":"Top Hat Probability Function Module","text":"<p>This module defines a class for handling the probability function of multiple top-hat-shaped subspaces within a larger spatial environment. A \"top-hat\" distribution is a flat or constant distribution within a defined subspace and zero outside of it, commonly used to model regions with a uniform density surrounded by an area with a different (typically lower) density.</p> <p>Since top-hat distributions are not continuous or analytical probability distributions, their probability must be computed manually. This module provides a class, <code>multiple_top_hat_probability</code>, to handle the calculation and retrieval of the probability values based on input positions. The probability is computed as a constant value inside the top-hat subspaces and a different constant value outside them.</p>"},{"location":"probability_functions_reference/#SMS_BP.probability_functions--key_features","title":"Key Features:","text":"<ul> <li>Probability calculation within and outside defined subspaces.</li> <li>Support for multiple top-hat subspaces, each defined by its center and radius.</li> <li>Ability to update parameters and recalculate probabilities as needed.</li> </ul>"},{"location":"probability_functions_reference/#SMS_BP.probability_functions--usage","title":"Usage:","text":"<p>An instance of the <code>multiple_top_hat_probability</code> class is initialized with the number of subspaces, their centers, radii, density difference, and overall space size. Once initialized, the object can be called with a position to return the probability at that location.</p> <p>Example: ```python prob_func = multiple_top_hat_probability(     num_subspace=3,     subspace_centers=np.array([[1, 1], [2, 2], [3, 3]]),     subspace_radius=np.array([1.0, 0.5, 0.75]),     density_dif=0.2,     cell=BaseCell type )</p> <p>prob = prob_func(np.array([1.5, 1.5]))</p>"},{"location":"probability_functions_reference/#SMS_BP.probability_functions--note","title":"Note:","text":"<p>After initialization, do not change the parameters directly. Use the update_parameters method to modify any values.</p>"},{"location":"probability_functions_reference/#SMS_BP.probability_functions.multiple_top_hat_probability","title":"<code>multiple_top_hat_probability</code>","text":"<p>Class for the probability function of multiple top hats within different cell types.</p> Source code in <code>SMS_BP/probability_functions.py</code> <pre><code>class multiple_top_hat_probability:\n    \"\"\"Class for the probability function of multiple top hats within different cell types.\"\"\"\n\n    def __init__(\n        self,\n        num_subspace: int,\n        subspace_centers: np.ndarray,\n        subspace_radius: np.ndarray,\n        density_dif: float,\n        cell: BaseCell,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the probability function.\n\n        Parameters:\n        -----------\n        num_subspace : int\n            Number of subspaces\n        subspace_centers : np.ndarray\n            Centers of each subspace (shape: [num_subspace, 3])\n        subspace_radius : np.ndarray\n            Radius of each subspace\n        density_dif : float\n            Difference in density between subspaces and non-subspaces\n        cell : BaseCell\n            Cell object defining the boundary\n        \"\"\"\n        self.num_subspace = num_subspace\n        self.subspace_centers = np.array(subspace_centers)\n        self.subspace_radius = np.array(subspace_radius)\n        self.density_dif = density_dif\n        self.cell = cell\n\n        # Calculate probabilities using cell's volume property\n        total_volume = self.cell.volume\n        self.subspace_probability = self._calculate_subspace_probability(\n            total_volume, self.density_dif\n        )\n        self.non_subspace_probability = self._calculate_non_subspace_probability(\n            total_volume, self.density_dif, self.num_subspace, self.subspace_radius\n        )\n\n    def __call__(self, position: np.ndarray, **kwargs) -&gt; float:\n        \"\"\"Returns the probability given a coordinate\"\"\"\n        if not isinstance(position, np.ndarray):\n            raise TypeError(\"Position must be a numpy array.\")\n\n        # First check if point is within the cell\n        if not self.cell.contains_point(*position):\n            return 0.0\n\n        # Then check if point is within any subspace\n        for i in range(self.num_subspace):\n            if (\n                np.linalg.norm(position - self.subspace_centers[i])\n                &lt;= self.subspace_radius[i]\n            ):\n                return self.subspace_probability\n\n        return self.non_subspace_probability\n\n    def _calculate_subspace_probability(\n        self, total_volume: float, density_dif: float\n    ) -&gt; float:\n        \"\"\"Calculate probability within subspaces\"\"\"\n        return density_dif / total_volume\n\n    def _calculate_non_subspace_probability(\n        self,\n        total_volume: float,\n        density_dif: float,\n        num_subspace: int,\n        subspace_radius: np.ndarray,\n    ) -&gt; float:\n        \"\"\"Calculate probability outside subspaces\"\"\"\n        total_subspace_volume = (\n            num_subspace * (4 / 3) * np.pi * np.mean(subspace_radius) ** 3\n        )\n        remaining_volume = total_volume - total_subspace_volume\n\n        if remaining_volume &lt;= 0:\n            return 0.0\n\n        return 1.0 / total_volume\n\n    @property\n    def num_subspace(self) -&gt; int:\n        \"\"\"Returns the number of subspaces.\"\"\"\n        return self._num_subspace\n\n    @num_subspace.setter\n    def num_subspace(self, value: int) -&gt; None:\n        if not isinstance(value, int):\n            raise TypeError(\"Number of subspaces must be an integer.\")\n        self._num_subspace = value\n\n    @property\n    def subspace_centers(self) -&gt; np.ndarray:\n        \"\"\"Returns the centers of the subspaces.\"\"\"\n        return self._subspace_centers\n\n    @subspace_centers.setter\n    def subspace_centers(self, value: np.ndarray) -&gt; None:\n        if not isinstance(value, np.ndarray):\n            raise TypeError(\"Subspace centers must be a numpy array.\")\n        self._subspace_centers = value\n\n    @property\n    def subspace_radius(self) -&gt; np.ndarray:\n        \"\"\"Returns the radius of the subspaces.\"\"\"\n        return self._subspace_radius\n\n    @subspace_radius.setter\n    def subspace_radius(self, value: np.ndarray) -&gt; None:\n        if not isinstance(value, np.ndarray):\n            raise TypeError(\"Subspace radius must be a numpy array.\")\n        self._subspace_radius = value\n\n    @property\n    def density_dif(self) -&gt; float:\n        \"\"\"Returns the difference in density between the subspaces and the rest of the space.\"\"\"\n        return self._density_dif\n\n    @density_dif.setter\n    def density_dif(self, value: float) -&gt; None:\n        self._density_dif = value\n\n    @property\n    def cell(self) -&gt; BaseCell:\n        \"\"\"Returns the cell object.\"\"\"\n        return self._cell\n\n    @cell.setter\n    def cell(self, value: BaseCell) -&gt; None:\n        self._cell = value\n\n    @property\n    def subspace_probability(self) -&gt; float:\n        return self._subspace_probability\n\n    @subspace_probability.setter\n    def subspace_probability(self, value: float) -&gt; None:\n        self._subspace_probability = value\n\n    @property\n    def non_subspace_probability(self) -&gt; float:\n        \"\"\"Returns the probability of the non-subspaces.\"\"\"\n        return self._non_subspace_probability\n\n    @non_subspace_probability.setter\n    def non_subspace_probability(self, value: float) -&gt; None:\n        self._non_subspace_probability = value\n\n    def update_parameters(\n        self,\n        num_subspace: int | None = None,\n        subspace_centers: np.ndarray | None = None,\n        subspace_radius: np.ndarray | None = None,\n        density_dif: float | None = None,\n        cell: BaseCell | None = None,\n    ) -&gt; None:\n        \"\"\"Updates the parameters of the probability function.\"\"\"\n        if num_subspace is not None:\n            self.num_subspace = num_subspace\n        if subspace_centers is not None:\n            self.subspace_centers = subspace_centers\n        if subspace_radius is not None:\n            self.subspace_radius = subspace_radius\n        if density_dif is not None:\n            self.density_dif = density_dif\n        if cell is not None:\n            self.cell = cell\n\n        self.subspace_probability = self._calculate_subspace_probability(\n            self.cell.volume, self.density_dif\n        )\n        self.non_subspace_probability = self._calculate_non_subspace_probability(\n            self.cell.volume, self.density_dif, self.num_subspace, self.subspace_radius\n        )\n</code></pre>"},{"location":"probability_functions_reference/#SMS_BP.probability_functions.multiple_top_hat_probability.cell","title":"<code>cell</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the cell object.</p>"},{"location":"probability_functions_reference/#SMS_BP.probability_functions.multiple_top_hat_probability.density_dif","title":"<code>density_dif</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the difference in density between the subspaces and the rest of the space.</p>"},{"location":"probability_functions_reference/#SMS_BP.probability_functions.multiple_top_hat_probability.non_subspace_probability","title":"<code>non_subspace_probability</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the probability of the non-subspaces.</p>"},{"location":"probability_functions_reference/#SMS_BP.probability_functions.multiple_top_hat_probability.num_subspace","title":"<code>num_subspace</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the number of subspaces.</p>"},{"location":"probability_functions_reference/#SMS_BP.probability_functions.multiple_top_hat_probability.subspace_centers","title":"<code>subspace_centers</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the centers of the subspaces.</p>"},{"location":"probability_functions_reference/#SMS_BP.probability_functions.multiple_top_hat_probability.subspace_radius","title":"<code>subspace_radius</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the radius of the subspaces.</p>"},{"location":"probability_functions_reference/#SMS_BP.probability_functions.multiple_top_hat_probability.__call__","title":"<code>__call__(position, **kwargs)</code>","text":"<p>Returns the probability given a coordinate</p> Source code in <code>SMS_BP/probability_functions.py</code> <pre><code>def __call__(self, position: np.ndarray, **kwargs) -&gt; float:\n    \"\"\"Returns the probability given a coordinate\"\"\"\n    if not isinstance(position, np.ndarray):\n        raise TypeError(\"Position must be a numpy array.\")\n\n    # First check if point is within the cell\n    if not self.cell.contains_point(*position):\n        return 0.0\n\n    # Then check if point is within any subspace\n    for i in range(self.num_subspace):\n        if (\n            np.linalg.norm(position - self.subspace_centers[i])\n            &lt;= self.subspace_radius[i]\n        ):\n            return self.subspace_probability\n\n    return self.non_subspace_probability\n</code></pre>"},{"location":"probability_functions_reference/#SMS_BP.probability_functions.multiple_top_hat_probability.__init__","title":"<code>__init__(num_subspace, subspace_centers, subspace_radius, density_dif, cell)</code>","text":"<p>Initialize the probability function.</p>"},{"location":"probability_functions_reference/#SMS_BP.probability_functions.multiple_top_hat_probability.__init__--parameters","title":"Parameters:","text":"<p>num_subspace : int     Number of subspaces subspace_centers : np.ndarray     Centers of each subspace (shape: [num_subspace, 3]) subspace_radius : np.ndarray     Radius of each subspace density_dif : float     Difference in density between subspaces and non-subspaces cell : BaseCell     Cell object defining the boundary</p> Source code in <code>SMS_BP/probability_functions.py</code> <pre><code>def __init__(\n    self,\n    num_subspace: int,\n    subspace_centers: np.ndarray,\n    subspace_radius: np.ndarray,\n    density_dif: float,\n    cell: BaseCell,\n) -&gt; None:\n    \"\"\"\n    Initialize the probability function.\n\n    Parameters:\n    -----------\n    num_subspace : int\n        Number of subspaces\n    subspace_centers : np.ndarray\n        Centers of each subspace (shape: [num_subspace, 3])\n    subspace_radius : np.ndarray\n        Radius of each subspace\n    density_dif : float\n        Difference in density between subspaces and non-subspaces\n    cell : BaseCell\n        Cell object defining the boundary\n    \"\"\"\n    self.num_subspace = num_subspace\n    self.subspace_centers = np.array(subspace_centers)\n    self.subspace_radius = np.array(subspace_radius)\n    self.density_dif = density_dif\n    self.cell = cell\n\n    # Calculate probabilities using cell's volume property\n    total_volume = self.cell.volume\n    self.subspace_probability = self._calculate_subspace_probability(\n        total_volume, self.density_dif\n    )\n    self.non_subspace_probability = self._calculate_non_subspace_probability(\n        total_volume, self.density_dif, self.num_subspace, self.subspace_radius\n    )\n</code></pre>"},{"location":"probability_functions_reference/#SMS_BP.probability_functions.multiple_top_hat_probability.update_parameters","title":"<code>update_parameters(num_subspace=None, subspace_centers=None, subspace_radius=None, density_dif=None, cell=None)</code>","text":"<p>Updates the parameters of the probability function.</p> Source code in <code>SMS_BP/probability_functions.py</code> <pre><code>def update_parameters(\n    self,\n    num_subspace: int | None = None,\n    subspace_centers: np.ndarray | None = None,\n    subspace_radius: np.ndarray | None = None,\n    density_dif: float | None = None,\n    cell: BaseCell | None = None,\n) -&gt; None:\n    \"\"\"Updates the parameters of the probability function.\"\"\"\n    if num_subspace is not None:\n        self.num_subspace = num_subspace\n    if subspace_centers is not None:\n        self.subspace_centers = subspace_centers\n    if subspace_radius is not None:\n        self.subspace_radius = subspace_radius\n    if density_dif is not None:\n        self.density_dif = density_dif\n    if cell is not None:\n        self.cell = cell\n\n    self.subspace_probability = self._calculate_subspace_probability(\n        self.cell.volume, self.density_dif\n    )\n    self.non_subspace_probability = self._calculate_non_subspace_probability(\n        self.cell.volume, self.density_dif, self.num_subspace, self.subspace_radius\n    )\n</code></pre>"},{"location":"run_cell_simulation_reference/","title":"Run Cell Simulation","text":""},{"location":"run_cell_simulation_reference/#run_cell_simulation_reference","title":"Run Cell Simulation Reference","text":"<p>run_cell_simulation.py</p> <p>This file contains the command-line interface (CLI) for the SMS_BP package, which is used for simulating single molecule localization microscopy experiments.</p> <p>The CLI is built using Typer and provides two main commands: 1. 'config': Generates a sample configuration file. 2. 'runsim': Runs the cell simulation using a provided configuration file.</p> <p>Main Components: - typer_app_sms_bp: The main Typer application object. - cell_simulation(): Callback function that displays the version information. - generate_config(): Command to generate a sample configuration file. - run_cell_simulation(): Command to run the cell simulation using a configuration file.</p> <p>Usage: - To generate a config file: python run_cell_simulation.py config [OPTIONS] - To run a simulation: python run_cell_simulation.py runsim [CONFIG_FILE]</p> <p>The file uses Rich for enhanced console output and progress tracking.</p>"},{"location":"run_cell_simulation_reference/#SMS_BP.run_cell_simulation.generate_config","title":"<code>generate_config(output_path=Path('.'), output_path_make_recursive=None)</code>","text":"<p>Generate a sample configuration file for the cell simulation and save it to the specified output path.</p> Source code in <code>SMS_BP/run_cell_simulation.py</code> <pre><code>@typer_app_sms_bp.command(name=\"config\")\ndef generate_config(\n    output_path: Annotated[\n        Path,\n        typer.Option(\"--output_path\", \"-o\", help=\"Path to the output file\"),\n    ] = Path(\".\"),\n    output_path_make_recursive: Annotated[\n        Optional[bool],\n        typer.Option(\n            \"--recursive_o\",\n            \"-r\",\n            help=\"Make the output directory if it does not exist\",\n        ),\n    ] = None,\n) -&gt; None:\n    \"\"\"\n    Generate a sample configuration file for the cell simulation and save it to the specified output path.\n    \"\"\"\n\n    with Progress(\n        SpinnerColumn(),\n        TextColumn(\"[progress.description]{task.description}\"),\n        transient=True,\n    ) as progress:\n        task_1 = progress.add_task(\n            description=\"Processing request to create a default config file ...\",\n            total=10,\n        )\n\n        # check if the output path is provided and is a valid directory | if not none\n\n        try:\n            output_path = Path(output_path)\n        except ValueError:\n            print(\"FileNotFoundError: Invalid output path.\")\n            raise typer.Abort()\n        # double check if the output path is a valid directory\n        if not output_path.is_dir():\n            # if not, make the directory\n            if output_path_make_recursive:\n                try:\n                    output_path.mkdir(parents=True, exist_ok=True)\n                except FileExistsError:\n                    print(f\"FileExistsError: Directory {output_path} already exists.\")\n            else:\n                print(f\"FileNotFoundError: {output_path} is not a valid directory.\")\n                raise typer.Abort()\n        # find the parent dir\n        project_directory = Path(__file__).parent\n        # find the config file\n        config_file = project_directory / \"sim_config.json\"\n        output_path = output_path / \"sim_config.json\"\n        # copy the config file to the output path\n\n        # complete last progress\n        progress.update(task_1, completed=10)\n\n        task_2 = progress.add_task(\n            description=\"Copying the config file to the output path ...\", total=10\n        )\n        try:\n            shutil.copy(config_file, output_path)\n        except FileNotFoundError:\n            rich.print(f\"Error: No config file found in {project_directory}.\")\n            raise typer.Abort()\n        progress.update(task_2, completed=10)\n        # complete\n        rich.print(f\"Config file saved to {output_path.resolve()}\")\n</code></pre>"},{"location":"run_cell_simulation_reference/#SMS_BP.run_cell_simulation.run_cell_simulation","title":"<code>run_cell_simulation(config_file)</code>","text":"<p>Run the cell simulation using the configuration file provided.</p> Source code in <code>SMS_BP/run_cell_simulation.py</code> <pre><code>@typer_app_sms_bp.command(name=\"runsim\")\ndef run_cell_simulation(\n    config_file: Annotated[Path, typer.Argument(help=\"Path to the configuration file\")],\n) -&gt; None:\n    \"\"\"\n    Run the cell simulation using the configuration file provided.\n    \"\"\"\n    from contextlib import contextmanager\n\n    @contextmanager\n    def progress_context():\n        progress = Progress(\n            SpinnerColumn(),\n            TextColumn(\"[progress.description]{task.description}\"),\n            transient=True,\n        )\n        try:\n            with progress:\n                yield progress\n        finally:\n            progress.stop()\n\n    # Use in functions\n    with progress_context() as progress:\n        start_task_1 = time.time()\n        task_1 = progress.add_task(\n            description=\"Processing request to run the simulation ...\", total=10\n        )\n\n        # check if the config file is a valid file\n        if not os.path.isfile(config_file):\n            rich.print(\"FileNotFoundError: Configuration file not found.\")\n            raise typer.Abort()\n        # check if the config file is a valid json file\n        try:\n            with open(config_file) as f:\n                config = json.load(f)\n        except json.JSONDecodeError:\n            rich.print(\"JSONDecodeError: Configuration file is not a valid JSON file.\")\n            raise typer.Abort()\n\n        validate_config(config)\n\n        output_parameters = config[\"Output_Parameters\"]\n        output_path = output_parameters[\"output_path\"]\n\n        # find the version flag in the config file\n        if \"version\" in config:\n            version = config[\"version\"]\n            rich.print(f\"Using config version: [bold]{version}[/bold]\")\n        # complete last progress\n        progress.update(task_1, completed=10)\n        rich.print(\n            \"Prep work done in {:.2f} seconds.\".format(time.time() - start_task_1)\n        )\n\n        time_task_2 = time.time()\n        task_2 = progress.add_task(description=\"Running the simulation ...\", total=None)\n        # run the simulation\n        sim = Simulate_cells(str(config_file))\n        sim.get_and_save_sim(\n            cd=output_path,\n            img_name=output_parameters.get(\"output_name\"),\n            subsegment_type=output_parameters.get(\"subsegment_type\"),\n            subsegment_num=int(output_parameters.get(\"subsegment_number\")),\n        )\n\n        progress.update(task_2, completed=None)\n        rich.print(\n            \"Simulation completed in {:.2f} seconds.\".format(time.time() - time_task_2)\n        )\n</code></pre>"},{"location":"sim_config/","title":"sim_config Documentation","text":""},{"location":"sim_config/#documentation_for_the_simulation_configuration_file_of_the_same_name","title":"Documentation for the simulation configuration file of the same name","text":"<ul> <li>Simulation Configuration File</li> <li>Latest version supported: v.0.1</li> </ul>"},{"location":"sim_config/#simulation_configuration_file","title":"Simulation Configuration File","text":"<ul> <li>version: string<ul> <li>version of the simulation configuration file</li> </ul> </li> <li>length_unit: string<ul> <li>length unit of the simulation (e.g. nm, um, mm)</li> </ul> </li> <li>space_unit: string<ul> <li>space unit of the simulation (this is just pixel, should not change)</li> </ul> </li> <li>time_unit: string<ul> <li>time unit of the simulation (e.g. s, ms, us)</li> </ul> </li> <li>intensity_unit: string<ul> <li>intensity unit of the simulation (AUD only supported)</li> </ul> </li> <li> <p>diffusion_unit: string</p> <ul> <li>diffusion unit of the simulation (e.g. um^2/s, mm^2/s)</li> </ul> </li> <li> <p>Cell_Parameters: dict  </p> </li> </ul>"},{"location":"sim_config/#cell_type","title":"<code>cell_type</code>","text":"<ul> <li>Type: Union[str, CellType]</li> <li>Description: Defines the type of the cell to simulate.</li> <li>Supported: RectangularCell, SphericalCell, OvoidCell, RodCell, BuddingCell</li> </ul>"},{"location":"sim_config/#params","title":"<code>params</code>","text":"<ul> <li>Type: dictionary of parameter names (String) and values (Any)</li> <li>Description: Values for the cell_type specified above. The following the general structure:</li> </ul> <pre><code># SphericalCell\nparams = {\n    \"center\": [0, 0, 0],   # 3D center coordinates\n    \"radius\": 10.0         # Radius of sphere\n}\n</code></pre> <pre><code># RodCell\nparams = {\n    \"center\": [0, 0, 0],       # 3D center coordinates\n    \"direction\": [0, 0, 1],    # Direction vector (will be normalized)\n    \"height\": 20.0,            # Length of the rod\n    \"radius\": 5.0              # Radius of the rod\n}\n</code></pre> <pre><code># RectangularCell\nparams = {\n    \"bounds\": [-10, 10, -10, 10, -10, 10]  # [xmin, xmax, ymin, ymax, zmin, zmax]\n}\n</code></pre> <pre><code># OvoidCell\nparams = {\n    \"center\": [0, 0, 0],       # 3D center coordinates\n    \"xradius\": 10.0,           # Radius in x-direction\n    \"yradius\": 15.0,           # Radius in y-direction\n    \"zradius\": 20.0            # Radius in z-direction\n}\n</code></pre> <ul> <li> <p>Track_Parameters: dict  </p> <ul> <li>num_tracks: int<ol> <li>number of tracks to simulate</li> </ol> </li> <li>track_type: string<ol> <li>type of track to simulate (\"fbm\")</li> </ol> </li> <li>track_length_mean: int (frames) <ol> <li>mean length of the track</li> </ol> </li> <li>track_distribution: string<ol> <li>distribution of the track lengths (\"exponential\",\"constant\")</li> </ol> </li> <li>diffusion_coefficient: list of floats (units of diffusion_unit)<ol> <li>diffusion coefficient of the track, the length of the list is the unique type of diffusion coefficients</li> </ol> </li> <li>diffusion_track_amount: list of floats<ol> <li>Only viable if allow_transition_probability is False</li> <li>length is the total number of diffusion coefficients</li> <li>each element is the probability of the track having the diffusion coefficient at the same index in the diffusion_coefficient list (add up to 1.0)</li> </ol> </li> <li>hurst_exponent: list of floats<ol> <li>hurst exponent of the track, the length of the list is the unique type of hurst exponents</li> </ol> </li> <li>hurst_track_amount: list of floats<ol> <li>Only viable if allow_transition_probability is False</li> <li>length is the total number of hurst exponents</li> <li>each element is the probability of the track having the hurst exponent at the same index in the hurst_exponent list (add up to 1.0)</li> </ol> </li> <li>allow_transition_probability: bool<ol> <li>whether to allow transition probabilities between different diffusion coefficients and hurst exponents within a track</li> <li>if false, the track will have a single diffusion coefficient and hurst exponent</li> </ol> </li> <li>transition_matrix_time_step: int<ol> <li>time step at which the diffusion and hurst exponent transition matrices are supplied in the following parameters</li> <li>the units are in time_unit (so 100 ms would be 100)</li> </ol> </li> <li>diffusion_transition_matrix: 2D array (discrete state probabilitiy at the transition_matrix_time_step = dt)<ol> <li>transition matrix between different diffusion coefficients</li> <li>rows are the current diffusion coefficient</li> <li>columns are the next diffusion coefficient</li> <li>rows must sum to 1.0</li> </ol> </li> <li>hurst_transition_matrix: 2D array (discrete state probabilitiy at the transition_matrix_time_step = dt)<ol> <li>transition matrix between different hurst exponents</li> <li>rows are the current hurst exponent</li> <li>columns are the next hurst exponent</li> <li>rows must sum to 1.0</li> </ol> </li> <li>state_probability_diffusion: 1D array (probability)<ol> <li>probability of a track being in a certain diffusion coefficient state</li> <li>length is the number of unique diffusion coefficients</li> </ol> </li> <li>state_probability_hurst: 1D array (probability)<ol> <li>probability of a track being in a certain hurst exponent state</li> <li>length is the number of unique hurst exponents</li> </ol> </li> </ul> </li> <li> <p>Global_Parameters: dict  </p> <ul> <li>field_of_view_dim: 1D array (units of space_unit)<ol> <li>field of view dimensions (x,y (pixels))</li> </ol> </li> <li>frame_count: int<ol> <li>number of frames to simulate</li> </ol> </li> <li>exposure_time: float or int (units of time_unit)<ol> <li>exposure time of the camera</li> </ol> </li> <li>interval_time: float or int (units of time_unit)<ol> <li>time between frames that the camera is on</li> </ol> </li> <li>oversample_motion_time: float or int (units of time_unit)<ol> <li>oversampling the motion for motion blur</li> <li>if oversample_motion_time == frame_time == exposure_time, then there is no motion blur</li> <li>cannot be greater than frame_time or exposure_time</li> </ol> </li> <li>pixel_size: float (units of length_unit)<ol> <li>size of the pixel</li> </ol> </li> <li>axial_detection_range: float (units of length_unit)<ol> <li>from z=0, the distance in either direction that the camera can detect a single molecule excitation</li> </ol> </li> <li>base_noise: float (units of intensity_unit)<ol> <li>base noise of the camera (offset)</li> </ol> </li> <li>point_intensity: float (units of intensity_unit)<ol> <li>intensity of a single molecule excitation</li> </ol> </li> <li>psf_sigma: float (units of length_unit)<ol> <li>size of the psf (assumed to be gaussian)</li> </ol> </li> <li>axial_function: string (\"exponential\",\"ones\"(no effect))<ol> <li>function used to determine how the intensity of the single molecule changes with z</li> </ol> </li> </ul> </li> <li> <p>Condensate_Parameters: dict  </p> <ul> <li>initial_centers: 2D array (units of space_unit)<ol> <li>initial centers of the condensates</li> <li>[x,y,z] coordinates per row</li> <li>number of rows is the number of condensates</li> </ol> </li> <li>initial_scale: 1D (units of space_unit)<ol> <li>initial radius of the condensates</li> <li>number of elements is the number of condensates</li> <li>must be the same length as initial_centers</li> </ol> </li> <li>diffusion_coefficient: 1D array (units of diffusion_unit)<ol> <li>diffusion coefficient of the condensates</li> <li>number of elements is the number of condensates</li> <li>must be the same length as initial_centers</li> </ol> </li> <li>hurst_exponent: 1D array<ol> <li>hurst exponent of the condensates</li> <li>number of elements is the number of condensates</li> <li>must be the same length as initial_centers</li> </ol> </li> <li>density_dif: float<ol> <li>density difference between the condensates and the rest of the cell</li> </ol> </li> </ul> </li> <li> <p>Output_Parameters: dict  </p> <ul> <li>output_path: string<ol> <li>path to save the output, directory</li> </ol> </li> <li>output_name: string<ol> <li>name of the output file *subsegment_type: string</li> <li>function used to do projections (\"mean\",\"max\",\"sum\")</li> </ol> </li> <li>subsegment_number: int<ol> <li>number of subsegments to divide the cell frames into</li> <li>if total movie is 500 frames and this is 5 then there will be 100 frames per subsegment and 5 subsegments in total</li> <li>Make sure that the total number of frames is divisible by the number of subsegments (modulus is 0)</li> </ol> </li> </ul> </li> </ul>"},{"location":"simulate_cell_reference/","title":"Simulate Cell","text":""},{"location":"simulate_cell_reference/#simulate_cell_reference","title":"Simulate Cell Reference","text":""},{"location":"simulate_cell_reference/#SMS_BP.simulate_cell.Simulate_cells","title":"<code>Simulate_cells</code>","text":"Source code in <code>SMS_BP/simulate_cell.py</code> <pre><code>class Simulate_cells:\n    def __init__(self, init_dict_json: dict | str | SimulationConfig):\n        \"\"\"Docstring for Simulate_cells: Class for simulating cells in space.\n        Parameters:\n        -----------\n        init_dict_json : dict|str\n            dictionary of parameters or path to the json file containing the parameters\n            see sim_config.md for more details\n        Returns:\n        --------\n        None\n        \"\"\"\n        if isinstance(init_dict_json, str):\n            self.simulation_config = load_validate_and_convert(init_dict_json)\n            with open(init_dict_json, \"r\") as file:\n                self.loaded_config = json.load(file)\n        elif isinstance(init_dict_json, dict):\n            self.simulation_config = validate_and_convert(init_dict_json)\n            self.loaded_config = init_dict_json\n        else:\n            self.simulation_config = init_dict_json\n\n        self.simulation_config.make_array()\n        # store the times\n        self.frame_count = self.simulation_config.Global_Parameters.frame_count\n        self.cell = create_cell(\n            self.simulation_config.Cell_Parameters.cell_type,\n            self.simulation_config.Cell_Parameters.params,\n        )\n        self.interval_time = int(self.simulation_config.Global_Parameters.interval_time)\n        self.oversample_motion_time = int(\n            self.simulation_config.Global_Parameters.oversample_motion_time\n        )\n        self.exposure_time = int(self.simulation_config.Global_Parameters.exposure_time)\n        self.total_time = self._convert_frame_to_time(\n            self.frame_count,\n            self.exposure_time,\n            self.interval_time,\n            self.oversample_motion_time,\n        )\n        # convert the track_length_mean from frame to time\n        self.track_length_mean = self._convert_frame_to_time(\n            self.simulation_config.Track_Parameters.track_length_mean,\n            self.exposure_time,\n            self.interval_time,\n            self.oversample_motion_time,\n        )\n\n        # update the diffusion coefficients from um^2/s to pix^2/s\n        self.track_diffusion_updated = self._update_units(\n            self.simulation_config.Track_Parameters.diffusion_coefficient,\n            \"um^2/s\",\n            \"pix^2/s\",\n        )\n        self.condensate_diffusion_updated = self._update_units(\n            self.simulation_config.Condensate_Parameters.diffusion_coefficient,\n            \"um^2/s\",\n            \"pix^2/s\",\n        )\n        # update the pixel_size,axial_detection_range,psf_sigma from um to pix\n        self.pixel_size_pix = self._update_units(\n            self.simulation_config.Global_Parameters.pixel_size, \"um\", \"pix\"\n        )\n        self.axial_detection_range_pix = self._update_units(\n            self.simulation_config.Global_Parameters.axial_detection_range, \"um\", \"pix\"\n        )\n        self.psf_sigma_pix = self._update_units(\n            self.simulation_config.Global_Parameters.psf_sigma, \"um\", \"pix\"\n        )\n\n        if self.simulation_config.Track_Parameters.allow_transition_probability:\n            # convert the transition matrix from the time given to the oversample_motion_time\n            # store the transition_matrix_time_step\n            self.transition_matrix_time_step = (\n                self.simulation_config.Track_Parameters.transition_matrix_time_step\n            )\n\n            # check if the diffusion_coefficient and hurst_exponent are of length n, and then check if the length of the transition matrix is the same as the length of the diffusion_coefficient and hurst_exponent\n            if len(\n                self.simulation_config.Track_Parameters.diffusion_coefficient\n            ) != len(\n                self.simulation_config.Track_Parameters.diffusion_transition_matrix\n            ):\n                raise ValueError(\n                    \"The length of the diffusion_coefficient and the diffusion_transition_matrix are not the same\"\n                )\n            if len(self.simulation_config.Track_Parameters.hurst_exponent) != len(\n                self.simulation_config.Track_Parameters.hurst_transition_matrix\n            ):\n                raise ValueError(\n                    \"The length of the hurst_exponent and the hurst_transition_matrix are not the same\"\n                )\n            # compare to the oversample_motion_time and scale to the appropriate time step\n            if len(self.simulation_config.Track_Parameters.diffusion_coefficient) != 1:\n                self.diffusion_transition_matrix = np.real(\n                    fractional_matrix_power(\n                        self.simulation_config.Track_Parameters.diffusion_transition_matrix,\n                        self.oversample_motion_time / self.transition_matrix_time_step,\n                    )\n                )\n            else:\n                self.diffusion_transition_matrix = (\n                    self.simulation_config.Track_Parameters.diffusion_transition_matrix\n                )\n            if len(self.simulation_config.Track_Parameters.hurst_exponent) != 1:\n                self.hurst_transition_matrix = np.real(\n                    fractional_matrix_power(\n                        self.simulation_config.Track_Parameters.hurst_transition_matrix,\n                        self.oversample_motion_time / self.transition_matrix_time_step,\n                    )\n                )\n            else:\n                self.hurst_transition_matrix = (\n                    self.simulation_config.Track_Parameters.hurst_transition_matrix\n                )\n        return\n\n    def _convert_frame_to_time(\n        self,\n        frame: int,\n        exposure_time: int,\n        interval_time: int,\n        oversample_motion_time: int,\n    ) -&gt; int:\n        \"\"\"Docstring for _convert_frame_to_time: convert the frame number to time\n        Parameters:\n        -----------\n        frame : int\n            frame number\n        exposure_time : int\n            exposure time\n        interval_time : int\n            interval time\n        oversample_motion_time : int\n            oversample motion time\n        Returns:\n        --------\n        int\n            time in the appropriate units\n        \"\"\"\n        return int((frame * (exposure_time + interval_time)) / oversample_motion_time)\n\n    def _update_units(\n        self, unit: np.ndarray | float | int, orig_type: str, update_type: str\n    ) -&gt; float | np.ndarray | None:\n        \"\"\"Docstring for _update_units: update the unit from one type to another\n        Parameters:\n        -----------\n        unit : float|np.ndarray\n            unit to be updated\n        orig_type : str\n            original type of unit\n        update_type : str\n            type to update unit to\n        \"\"\"\n        unit = np.array(unit)\n        if orig_type == \"nm\":\n            if update_type == \"pix\":\n                return unit / self.simulation_config.Global_Parameters.pixel_size\n        elif orig_type == \"pix\":\n            if update_type == \"nm\":\n                return unit * self.simulation_config.Global_Parameters.pixel_size\n        elif orig_type == \"ms\":\n            if update_type == \"s\":\n                return unit / 1000.0\n        elif orig_type == \"s\":\n            if update_type == \"ms\":\n                return unit * 1000.0\n        elif orig_type == \"um^2/s\":\n            if update_type == \"pix^2/s\":\n                return unit * (\n                    1.0 / (self.simulation_config.Global_Parameters.pixel_size**2)\n                )\n        if orig_type == \"um\":\n            if update_type == \"pix\":\n                return unit / self.simulation_config.Global_Parameters.pixel_size\n\n    def _check_init_dict(self) -&gt; bool:\n        \"\"\"Docstring for _check_init_dict: check the init_dict for the required keys, and if they are consistent with other keys\n\n        Parameters:\n        -----------\n        None\n\n        Returns:\n        --------\n        bool: True if the init_dict is correct\n\n        Raises:\n        -------\n        InitializationKeys: if the init_dict does not have the required keys\n        InitializationValues: if the init_dict values are not consistent with each other\n        \"\"\"\n        # check if the init_dict has the required keys\n        # TODO\n        return True\n\n    def _read_json(self, json_file: str) -&gt; dict:\n        \"\"\"Docstring for _read_json: read the json file and return the dictionary\n        Parameters:\n        -----------\n        json_file : str\n            path to the json file\n\n        Returns:\n        --------\n        dict\n            dictionary of parameters\n        \"\"\"\n        # Open the json file\n        with open(json_file) as f:\n            # Load the json file\n            data = json.load(f)\n        # Function to recursively convert lists to NumPy arrays\n\n        def convert_lists_to_arrays(obj):\n            if isinstance(obj, list):\n                return np.array(obj)\n            elif isinstance(obj, dict):\n                return {k: convert_lists_to_arrays(v) for k, v in obj.items()}\n            else:\n                return obj\n\n        # Convert lists to NumPy arrays\n        data = convert_lists_to_arrays(data)\n        return data\n\n    def _define_space(\n        self, dims: tuple[int, int] = (100, 100), movie_frames: int = 500\n    ) -&gt; np.ndarray:\n        \"\"\"Docstring for _define_space: make the empty space for simulation\n        Parameters:\n        -----------\n        dims : tuple, Default = (100,100)\n            dimensions of the space to be simulated\n        movie_frames : int, Default = 500\n            number of frames to be simulated\n        Returns:\n        --------\n        space : array-like, shape = (movie_frames,dims[0],dims[1])\n            empty space for simulation\n        \"\"\"\n        space = np.zeros((movie_frames, dims[0], dims[1]))\n        return space\n\n    def _convert_track_dict_points_per_frame(\n        self, tracks: dict, movie_frames: int\n    ) -&gt; dict:\n        \"\"\"\n        Convert the track dictionary into a dictionary of points per frame.\n\n        Parameters:\n        -----------\n        tracks : dict\n            Dictionary of tracks where keys are track numbers and values are track data.\n        movie_frames : int\n            Number of frames in the movie.\n\n        Returns:\n        --------\n        dict\n            Dictionary where keys are frame numbers and values are lists of (x, y, z) tuples representing points.\n        \"\"\"\n        points_per_frame = dict(\n            zip(\n                [str(i) for i in range(movie_frames)], [[] for i in range(movie_frames)]\n            )\n        )\n        for i, j in tracks.items():\n            for k in range(len(j[\"times\"])):\n                points_per_frame[str(j[\"times\"][k])].append(j[\"xy\"][k])\n\n        return points_per_frame\n\n    def _convert_track_dict_msd(self, tracks: dict) -&gt; dict:\n        \"\"\"\n        Convert the track dictionary to a format required for the MSD (mean square displacement) function.\n\n        Parameters:\n        -----------\n        tracks : dict\n            Dictionary of tracks where keys are track numbers and values are track data.\n\n        Returns:\n        --------\n        dict\n            Dictionary where keys are track numbers and values are lists of (x, y, T) tuples representing track points.\n        \"\"\"\n        track_msd = {}\n        for i, j in tracks.items():\n            # make a (x,y,T) tuple for each point\n            track_msd[i] = []\n            for k in range(len(j[\"xy\"])):\n                track_msd[i].append((j[\"xy\"][k][0], j[\"xy\"][k][1], j[\"times\"][k]))\n            # add this to the dictionary\n            track_msd[i] = np.array(track_msd[i])\n        return track_msd\n\n    def _create_track_pop_dict(self, simulation_cube: np.ndarray) -&gt; tuple[dict, dict]:\n        \"\"\"\n        Create the tracks for the cell simulation and return tracks and points per time.\n\n        Parameters:\n        -----------\n        simulation_cube : np.ndarray\n            Empty space for the simulation.\n\n        Returns:\n        --------\n        tuple[dict, dict]\n            A tuple where the first element is a dictionary of tracks, and the second element is a dictionary of points per time.\n        \"\"\"\n        # get the lengths of the tracks given a distribution\n        track_lengths = get_lengths(\n            track_distribution=self.simulation_config.Track_Parameters.track_distribution,\n            track_length_mean=self.track_length_mean,\n            total_tracks=self.simulation_config.Track_Parameters.num_tracks,\n        )\n        # if track_lengths is larger than the number of frames then set that to the number of frames -1\n        track_lengths = np.array(\n            [i if i &lt; self.total_time else self.total_time - 1 for i in track_lengths]\n        )\n        # for each track_lengths find the starting frame\n        starting_frames = np.array(\n            [random.randint(0, self.total_time - i) for i in track_lengths]\n        )\n\n        # initialize the Condensates. Assuming box shaped.\n        # find area assuming cell_space is [[min_x,max_x],[min_y,max_y]]\n        self.condensates = create_condensate_dict(\n            initial_centers=np.array(\n                self.simulation_config.Condensate_Parameters.initial_centers\n            ),\n            initial_scale=np.array(\n                self.simulation_config.Condensate_Parameters.initial_scale\n            ),\n            diffusion_coefficient=np.array(self.condensate_diffusion_updated),\n            hurst_exponent=np.array(\n                self.simulation_config.Condensate_Parameters.hurst_exponent\n            ),\n            units_time=np.array(\n                [\n                    str(self.simulation_config.Global_Parameters.oversample_motion_time)\n                    + self.simulation_config.time_unit\n                ]\n                * len(self.condensate_diffusion_updated)\n            ),\n            cell=self.cell,\n            oversample_motion_time=self.oversample_motion_time,\n        )\n\n        # define the top_hat class that will be used to sample the condensates\n        top_hat_func = multiple_top_hat_probability(\n            num_subspace=len(self.condensate_diffusion_updated),\n            subspace_centers=self.simulation_config.Condensate_Parameters.initial_centers,\n            subspace_radius=self.simulation_config.Condensate_Parameters.initial_scale,\n            density_dif=self.simulation_config.Condensate_Parameters.density_dif,\n            cell=self.cell,\n        )\n        # make a placeholder for the initial position array with all 0s\n        initials = np.zeros((self.simulation_config.Track_Parameters.num_tracks, 3))\n        # lets use the starting frames to find the inital position based on the position of the condensates\n        for i in range(self.simulation_config.Track_Parameters.num_tracks):\n            # get the starting time from the frame, oversample_motion_time, and interval_time\n            starting_frame = starting_frames[i]\n            # condensate positions\n            condensate_positions = np.zeros((len(self.condensates), 3))\n            # loop through the condensates\n            for ID, cond in self.condensates.items():\n                condensate_positions[int(ID)] = cond(\n                    int(starting_frame),\n                    str(self.simulation_config.Global_Parameters.oversample_motion_time)\n                    + self.simulation_config.time_unit,\n                )[\"Position\"]\n            # update the top_hat_func with the new condensate positions\n            top_hat_func.update_parameters(subspace_centers=condensate_positions)\n            # sample the top hat to get the initial position\n            initials[i] = generate_points_from_cls(\n                top_hat_func,\n                total_points=1,\n                volume=self.cell.volume,\n                bounds=self.cell.boundingbox,\n                density_dif=self.simulation_config.Condensate_Parameters.density_dif,\n            )[0]\n        # check to see if there is 2 or 3 values in the second dimension of initials\n        if initials.shape[1] == 2:\n            # add a third dimension of zeros so that the final shape is (num_tracks,3) with (:,3) being 0s\n            initials = np.hstack(\n                (\n                    initials,\n                    np.zeros((self.simulation_config.Track_Parameters.num_tracks, 1)),\n                )\n            )\n        # create tracks\n        tracks = {}\n        points_per_time = dict(\n            zip(\n                [str(i) for i in range(int(self.total_time))],\n                [[] for i in range(int(self.total_time))],\n            )\n        )\n        # initialize the Track_generator class\n        track_generator = Track_generator(\n            cell=self.cell,\n            total_time=self.frame_count * (self.interval_time + self.exposure_time),\n            oversample_motion_time=self.oversample_motion_time,\n        )\n        if self.simulation_config.Track_Parameters.track_type == \"constant\":\n            for i in range(self.simulation_config.Track_Parameters.num_tracks):\n                # make a constant track\n                tracks[i] = track_generator.track_generation_constant(\n                    track_length=track_lengths[i],\n                    initials=initials[i],\n                    start_time=starting_frames[i],\n                )\n                # add the number of points per frame to the dictionary\n                for j in range(len(tracks[i][\"times\"])):\n                    points_per_time[str(int(tracks[i][\"times\"][j]))].append(\n                        tracks[i][\"xy\"][j]\n                    )\n        elif not self.simulation_config.Track_Parameters.allow_transition_probability:\n            # for the amount of tracks make a choice from the diffusion and hurst parameters based on the probability from diffusion_track_amount, hurst_track_amount\n            # make an index of the track_diffusion_updated and hurst_exponent\n            index_diffusion = np.arange(len(self.track_diffusion_updated))\n            index_hurst = np.arange(\n                len(self.simulation_config.Track_Parameters.hurst_exponent)\n            )\n            track_diffusion_choice = np.random.choice(\n                index_diffusion,\n                size=self.simulation_config.Track_Parameters.num_tracks,\n                p=self.simulation_config.Track_Parameters.diffusion_track_amount,\n            )\n            track_hurst_choice = np.random.choice(\n                index_hurst,\n                size=self.simulation_config.Track_Parameters.num_tracks,\n                p=self.simulation_config.Track_Parameters.hurst_track_amount,\n            )\n            for i in range(self.simulation_config.Track_Parameters.num_tracks):\n                tracks_diffusion = self.track_diffusion_updated[\n                    track_diffusion_choice[i]\n                ]\n                tracks_hurst = self.simulation_config.Track_Parameters.hurst_exponent[\n                    track_hurst_choice[i]\n                ]\n                # make a track with no transition probability\n                tracks[i] = track_generator.track_generation_no_transition(\n                    diffusion_coefficient=tracks_diffusion,\n                    hurst_exponent=tracks_hurst,\n                    track_length=track_lengths[i],\n                    initials=initials[i],\n                    start_time=starting_frames[i],\n                )\n                # add the number of points per frame to the dictionary\n                for j in range(len(tracks[i][\"times\"])):\n                    points_per_time[str(int(tracks[i][\"times\"][j]))].append(\n                        tracks[i][\"xy\"][j]\n                    )\n        elif self.simulation_config.Track_Parameters.allow_transition_probability:\n            for i in range(self.simulation_config.Track_Parameters.num_tracks):\n                # make a track with transition probability\n                tracks[i] = track_generator.track_generation_with_transition(\n                    diffusion_transition_matrix=self.diffusion_transition_matrix,\n                    hurst_transition_matrix=self.hurst_transition_matrix,\n                    diffusion_parameters=self.track_diffusion_updated,\n                    hurst_parameters=self.simulation_config.Track_Parameters.hurst_exponent,\n                    diffusion_state_probability=self.simulation_config.Track_Parameters.state_probability_diffusion,\n                    hurst_state_probability=self.simulation_config.Track_Parameters.state_probability_hurst,\n                    track_length=track_lengths[i],\n                    initials=initials[i],\n                    start_time=starting_frames[i],\n                )\n                for j in range(len(tracks[i][\"times\"])):\n                    points_per_time[str(int(tracks[i][\"times\"][j]))].append(\n                        tracks[i][\"xy\"][j]\n                    )\n        return tracks, points_per_time\n\n    def _create_map(\n        self, initial_map: np.ndarray, points_per_frame: dict, axial_function: str\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Create the simulation map from points per frame.\n\n        Parameters:\n        -----------\n        initial_map : np.ndarray\n            Empty space for the simulation.\n        points_per_frame : dict\n            Dictionary of points per frame, where keys are frame numbers and values are point coordinates.\n        axial_function : str\n            The function used to generate axial intensity.\n\n        Returns:\n        --------\n        np.ndarray\n            Updated simulation map.\n        \"\"\"\n        for i in range(initial_map.shape[0]):\n            # if empty points_per_frame for frame i then do some house keeping\n            if len(points_per_frame[str(i)]) == 0:\n                abs_axial_position = (\n                    1.0\n                    * self.simulation_config.Global_Parameters.point_intensity\n                    * self.oversample_motion_time\n                    / self.exposure_time\n                )\n                points_per_frame_xyz = np.array(points_per_frame[str(i)])\n                points_per_frame_xyz = np.array(points_per_frame_xyz)\n            else:\n                abs_axial_position = (\n                    1.0\n                    * self.simulation_config.Global_Parameters.point_intensity\n                    * axial_intensity_factor(\n                        np.abs(np.array(points_per_frame[str(i)])[:, 2]),\n                        detection_range=self.axial_detection_range_pix,\n                        func=self.simulation_config.Global_Parameters.axial_function,\n                    )\n                    * self.oversample_motion_time\n                    / self.exposure_time\n                )\n                points_per_frame_xyz = np.array(points_per_frame[str(i)])[:, :2]\n            initial_map[i], _ = generate_map_from_points(\n                points_per_frame_xyz,\n                point_intensity=abs_axial_position,\n                map=initial_map[i],\n                movie=True,\n                base_noise=self.simulation_config.Global_Parameters.base_noise,\n                psf_sigma=self.psf_sigma_pix,\n            )\n        return initial_map\n\n    def _point_per_time_selection(self, points_per_time: dict) -&gt; dict:\n        \"\"\"\n        Select points per frame for the simulation, considering only points during the exposure time.\n\n        Parameters:\n        -----------\n        points_per_time : dict\n            Dictionary of points per time, where keys are frame numbers and values are lists of points.\n\n        Returns:\n        --------\n        dict\n            Dictionary of points per frame, filtered by exposure time.\n        \"\"\"\n        # The tracks and points_per_time are already created, so we just need to convert the points_per_time to points_per_frame\n        # we only select the points which are in every exposure time ignoring the interval time inbetween the exposure time\n        points_per_frame = dict(\n            zip(\n                [str(i) for i in range(self.frame_count)],\n                [[] for i in range(self.frame_count)],\n            )\n        )\n        exposure_counter = 0\n        interval_counter = 0\n        frame_counter = 0\n        for i in range(int(self.total_time)):\n            if (\n                exposure_counter &lt; int(self.exposure_time / self.oversample_motion_time)\n            ) and (\n                interval_counter\n                &lt;= int(self.interval_time / self.oversample_motion_time)\n            ):\n                # append the points to the points_per_frame\n                if len(points_per_time[str(i)]) != 0:\n                    for k in range(len(points_per_time[str(i)])):\n                        points_per_frame[str(frame_counter)].append(\n                            points_per_time[str(i)][k]\n                        )\n                # increment the exposure_counter\n                exposure_counter += 1\n            elif (\n                exposure_counter\n                == int(self.exposure_time / self.oversample_motion_time)\n            ) and (\n                interval_counter &lt; int(self.interval_time / self.oversample_motion_time)\n            ):\n                # increment the interval_counter\n                interval_counter += 1\n            if (\n                exposure_counter\n                == int(self.exposure_time / self.oversample_motion_time)\n            ) and (\n                interval_counter\n                == int(self.interval_time / self.oversample_motion_time)\n            ):\n                # reset the counters\n                exposure_counter = 0\n                interval_counter = 0\n                frame_counter += 1\n        return points_per_frame\n\n    def get_cell(self) -&gt; dict:\n        \"\"\"Docstring for get_cell: get the cell simulation\n        Parameters:\n        -----------\n        None\n        Returns:\n        --------\n        cell : dict\n            dictionary of the cell simulation, keys = \"map\",\"tracks\",\"points_per_frame\"\n        \"\"\"\n        # create the space for the simulation\n        space = self._define_space(\n            dims=self.simulation_config.Global_Parameters.field_of_view_dim,\n            movie_frames=self.frame_count,\n        )\n        # create the tracks and points_per_time\n        tracks, points_per_time = self._create_track_pop_dict(space)\n        points_per_frame = self._point_per_time_selection(points_per_time)\n\n        # update the space\n        space_updated = self._create_map(\n            initial_map=space,\n            points_per_frame=points_per_frame,\n            axial_function=self.simulation_config.Global_Parameters.axial_function,\n        )\n        return {\n            \"map\": space_updated,\n            \"tracks\": tracks,\n            \"points_per_frame\": points_per_frame,\n        }\n\n    def get_and_save_sim(\n        self,\n        cd: str,\n        img_name: str,\n        subsegment_type: str,\n        subsegment_num: int,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Docstring for make_directory_structure: make the directory structure for the simulation and save the image + the data and parameters\n        Also perform the subsegmentation and save the subsegments in the appropriate directory\n        Parameters:\n        -----------\n        cd : str\n            directory to save the simulation\n        img_name : str\n            name of the image\n        img : array-like\n            image to be subsegmented\n        subsegment_type : str\n            type of subsegmentation to be performed, currently only \"mean\" is supported\n        subsegment_num : int\n            number of subsegments to be created\n        **kwargs : dict\n            dictionary of keyword arguments\n        KWARGS:\n        -------\n        data : dict, Default = None\n            dictionary of data to be saved, Keys = \"map\",\"tracks\",\"points_per_frame\" Values = array-like.\n            See the return of the function simulate_cell_tracks for more details\n        parameters : dict, Default = self.simulation_config\n        Returns:\n        --------\n        none\n        \"\"\"\n        # run the sim\n        sim = self.get_cell()\n        # add notes to explain data structure.\n        ppf_note = \"points_per_frame is a dictionary representing the frame number (keys) and accociated molecule positions in those frames (values). Units for frames is count; units for points is image pixel units. Note that there can be more than one molecule localization per frame if the motion is oversampled relative to the exposure time.\"\n        tracks_note = f\"the tracks dictionary contains the following keys: xy, times, diffusion_coefficient, hurst, and initial.  \\n 1) xy represents the xyz positions of the molecule in units of the image pixels. \\n 2) times represents the base time unit at which the molecule positions in 1) occur. This is in units of the oversample_motion_time. One value represents 1 * oversample_motion_time ms ({self.oversample_motion_time} ms in this case) in time (ms). To convert times to ms multiply the array element-wise by the oversample_motion_time ({self.oversample_motion_time}). \\n 3) diffusion_coefficient is the value of the diffusion_coefficient at the base time value in 2). The units of the diffusion_coefficient are in pixels^2/s . \\n 4) hurst represents the hurst exponent for the times in 2) of this molecule (similar to the diffusion_coefficient); this value is unitless. \\n 5) initials represents the inital xyz value of this molecule in image pixel units.\"\n        sim[\"tracks\"][\"tracks_notes\"] = tracks_note\n        sim[\"points_per_frame_notes\"] = ppf_note\n\n        # update the kwargs with the data\n        kwargs[\"data\"] = sim\n        kwargs[\"parameters\"] = self.loaded_config\n        # make the directory structure\n        _ = make_directory_structure(\n            cd, img_name, sim[\"map\"], subsegment_type, subsegment_num, **kwargs\n        )\n        return None\n\n    @property\n    def condensates(self) -&gt; dict:\n        return self._condensates\n\n    @condensates.setter\n    def condensates(self, condensates: dict):\n        self._condensates = condensates\n\n    @deprecated(\n        \"This function is not useful, but is still here for a while in case I need it later\"\n    )\n    def _format_points_per_frame(self, points_per_frame):\n        \"\"\"\n        Docstring for _format_points_per_frame: format the points per frame dictionary so that for each key the set of tracks in it are\n        converted to a numpy array of N x 2 where N is the total amount of points in that frame. You don't need this function.\n\n        Parameters:\n        -----------\n        points_per_frame : dict\n            keys = str(i) for i in range(self.total_time), values = list of tracks, which are collections of [x,y] coordinates\n\n        Returns:\n        --------\n        points_per_frame : dict\n            keys = str(i) for i in range(movie_frames), values = numpy array of N x 2 where N is the total amount of points in that frame\n\n        \"\"\"\n        for i in points_per_frame.keys():\n            # each value is a list of K lists that are composed of M x 2 arrays where M can be different for each list\n            # we want to convert this to a numpy array of N x 2 where N is the total amount of points in that frame\n            point_holder = []\n            for j in points_per_frame[i]:\n                point_holder.append(j)\n            points_per_frame[i] = np.array(point_holder)\n        return points_per_frame\n</code></pre>"},{"location":"simulate_cell_reference/#SMS_BP.simulate_cell.Simulate_cells.__init__","title":"<code>__init__(init_dict_json)</code>","text":"<p>Docstring for Simulate_cells: Class for simulating cells in space. Parameters:</p> <p>init_dict_json : dict|str     dictionary of parameters or path to the json file containing the parameters     see sim_config.md for more details Returns:</p> <p>None</p> Source code in <code>SMS_BP/simulate_cell.py</code> <pre><code>def __init__(self, init_dict_json: dict | str | SimulationConfig):\n    \"\"\"Docstring for Simulate_cells: Class for simulating cells in space.\n    Parameters:\n    -----------\n    init_dict_json : dict|str\n        dictionary of parameters or path to the json file containing the parameters\n        see sim_config.md for more details\n    Returns:\n    --------\n    None\n    \"\"\"\n    if isinstance(init_dict_json, str):\n        self.simulation_config = load_validate_and_convert(init_dict_json)\n        with open(init_dict_json, \"r\") as file:\n            self.loaded_config = json.load(file)\n    elif isinstance(init_dict_json, dict):\n        self.simulation_config = validate_and_convert(init_dict_json)\n        self.loaded_config = init_dict_json\n    else:\n        self.simulation_config = init_dict_json\n\n    self.simulation_config.make_array()\n    # store the times\n    self.frame_count = self.simulation_config.Global_Parameters.frame_count\n    self.cell = create_cell(\n        self.simulation_config.Cell_Parameters.cell_type,\n        self.simulation_config.Cell_Parameters.params,\n    )\n    self.interval_time = int(self.simulation_config.Global_Parameters.interval_time)\n    self.oversample_motion_time = int(\n        self.simulation_config.Global_Parameters.oversample_motion_time\n    )\n    self.exposure_time = int(self.simulation_config.Global_Parameters.exposure_time)\n    self.total_time = self._convert_frame_to_time(\n        self.frame_count,\n        self.exposure_time,\n        self.interval_time,\n        self.oversample_motion_time,\n    )\n    # convert the track_length_mean from frame to time\n    self.track_length_mean = self._convert_frame_to_time(\n        self.simulation_config.Track_Parameters.track_length_mean,\n        self.exposure_time,\n        self.interval_time,\n        self.oversample_motion_time,\n    )\n\n    # update the diffusion coefficients from um^2/s to pix^2/s\n    self.track_diffusion_updated = self._update_units(\n        self.simulation_config.Track_Parameters.diffusion_coefficient,\n        \"um^2/s\",\n        \"pix^2/s\",\n    )\n    self.condensate_diffusion_updated = self._update_units(\n        self.simulation_config.Condensate_Parameters.diffusion_coefficient,\n        \"um^2/s\",\n        \"pix^2/s\",\n    )\n    # update the pixel_size,axial_detection_range,psf_sigma from um to pix\n    self.pixel_size_pix = self._update_units(\n        self.simulation_config.Global_Parameters.pixel_size, \"um\", \"pix\"\n    )\n    self.axial_detection_range_pix = self._update_units(\n        self.simulation_config.Global_Parameters.axial_detection_range, \"um\", \"pix\"\n    )\n    self.psf_sigma_pix = self._update_units(\n        self.simulation_config.Global_Parameters.psf_sigma, \"um\", \"pix\"\n    )\n\n    if self.simulation_config.Track_Parameters.allow_transition_probability:\n        # convert the transition matrix from the time given to the oversample_motion_time\n        # store the transition_matrix_time_step\n        self.transition_matrix_time_step = (\n            self.simulation_config.Track_Parameters.transition_matrix_time_step\n        )\n\n        # check if the diffusion_coefficient and hurst_exponent are of length n, and then check if the length of the transition matrix is the same as the length of the diffusion_coefficient and hurst_exponent\n        if len(\n            self.simulation_config.Track_Parameters.diffusion_coefficient\n        ) != len(\n            self.simulation_config.Track_Parameters.diffusion_transition_matrix\n        ):\n            raise ValueError(\n                \"The length of the diffusion_coefficient and the diffusion_transition_matrix are not the same\"\n            )\n        if len(self.simulation_config.Track_Parameters.hurst_exponent) != len(\n            self.simulation_config.Track_Parameters.hurst_transition_matrix\n        ):\n            raise ValueError(\n                \"The length of the hurst_exponent and the hurst_transition_matrix are not the same\"\n            )\n        # compare to the oversample_motion_time and scale to the appropriate time step\n        if len(self.simulation_config.Track_Parameters.diffusion_coefficient) != 1:\n            self.diffusion_transition_matrix = np.real(\n                fractional_matrix_power(\n                    self.simulation_config.Track_Parameters.diffusion_transition_matrix,\n                    self.oversample_motion_time / self.transition_matrix_time_step,\n                )\n            )\n        else:\n            self.diffusion_transition_matrix = (\n                self.simulation_config.Track_Parameters.diffusion_transition_matrix\n            )\n        if len(self.simulation_config.Track_Parameters.hurst_exponent) != 1:\n            self.hurst_transition_matrix = np.real(\n                fractional_matrix_power(\n                    self.simulation_config.Track_Parameters.hurst_transition_matrix,\n                    self.oversample_motion_time / self.transition_matrix_time_step,\n                )\n            )\n        else:\n            self.hurst_transition_matrix = (\n                self.simulation_config.Track_Parameters.hurst_transition_matrix\n            )\n    return\n</code></pre>"},{"location":"simulate_cell_reference/#SMS_BP.simulate_cell.Simulate_cells.get_and_save_sim","title":"<code>get_and_save_sim(cd, img_name, subsegment_type, subsegment_num, **kwargs)</code>","text":"<p>Docstring for make_directory_structure: make the directory structure for the simulation and save the image + the data and parameters Also perform the subsegmentation and save the subsegments in the appropriate directory Parameters:</p> <p>cd : str     directory to save the simulation img_name : str     name of the image img : array-like     image to be subsegmented subsegment_type : str     type of subsegmentation to be performed, currently only \"mean\" is supported subsegment_num : int     number of subsegments to be created **kwargs : dict     dictionary of keyword arguments KWARGS:</p> <p>data : dict, Default = None     dictionary of data to be saved, Keys = \"map\",\"tracks\",\"points_per_frame\" Values = array-like.     See the return of the function simulate_cell_tracks for more details parameters : dict, Default = self.simulation_config Returns:</p> <p>none</p> Source code in <code>SMS_BP/simulate_cell.py</code> <pre><code>def get_and_save_sim(\n    self,\n    cd: str,\n    img_name: str,\n    subsegment_type: str,\n    subsegment_num: int,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Docstring for make_directory_structure: make the directory structure for the simulation and save the image + the data and parameters\n    Also perform the subsegmentation and save the subsegments in the appropriate directory\n    Parameters:\n    -----------\n    cd : str\n        directory to save the simulation\n    img_name : str\n        name of the image\n    img : array-like\n        image to be subsegmented\n    subsegment_type : str\n        type of subsegmentation to be performed, currently only \"mean\" is supported\n    subsegment_num : int\n        number of subsegments to be created\n    **kwargs : dict\n        dictionary of keyword arguments\n    KWARGS:\n    -------\n    data : dict, Default = None\n        dictionary of data to be saved, Keys = \"map\",\"tracks\",\"points_per_frame\" Values = array-like.\n        See the return of the function simulate_cell_tracks for more details\n    parameters : dict, Default = self.simulation_config\n    Returns:\n    --------\n    none\n    \"\"\"\n    # run the sim\n    sim = self.get_cell()\n    # add notes to explain data structure.\n    ppf_note = \"points_per_frame is a dictionary representing the frame number (keys) and accociated molecule positions in those frames (values). Units for frames is count; units for points is image pixel units. Note that there can be more than one molecule localization per frame if the motion is oversampled relative to the exposure time.\"\n    tracks_note = f\"the tracks dictionary contains the following keys: xy, times, diffusion_coefficient, hurst, and initial.  \\n 1) xy represents the xyz positions of the molecule in units of the image pixels. \\n 2) times represents the base time unit at which the molecule positions in 1) occur. This is in units of the oversample_motion_time. One value represents 1 * oversample_motion_time ms ({self.oversample_motion_time} ms in this case) in time (ms). To convert times to ms multiply the array element-wise by the oversample_motion_time ({self.oversample_motion_time}). \\n 3) diffusion_coefficient is the value of the diffusion_coefficient at the base time value in 2). The units of the diffusion_coefficient are in pixels^2/s . \\n 4) hurst represents the hurst exponent for the times in 2) of this molecule (similar to the diffusion_coefficient); this value is unitless. \\n 5) initials represents the inital xyz value of this molecule in image pixel units.\"\n    sim[\"tracks\"][\"tracks_notes\"] = tracks_note\n    sim[\"points_per_frame_notes\"] = ppf_note\n\n    # update the kwargs with the data\n    kwargs[\"data\"] = sim\n    kwargs[\"parameters\"] = self.loaded_config\n    # make the directory structure\n    _ = make_directory_structure(\n        cd, img_name, sim[\"map\"], subsegment_type, subsegment_num, **kwargs\n    )\n    return None\n</code></pre>"},{"location":"simulate_cell_reference/#SMS_BP.simulate_cell.Simulate_cells.get_cell","title":"<code>get_cell()</code>","text":"<p>Docstring for get_cell: get the cell simulation Parameters:</p> <p>None Returns:</p> <p>cell : dict     dictionary of the cell simulation, keys = \"map\",\"tracks\",\"points_per_frame\"</p> Source code in <code>SMS_BP/simulate_cell.py</code> <pre><code>def get_cell(self) -&gt; dict:\n    \"\"\"Docstring for get_cell: get the cell simulation\n    Parameters:\n    -----------\n    None\n    Returns:\n    --------\n    cell : dict\n        dictionary of the cell simulation, keys = \"map\",\"tracks\",\"points_per_frame\"\n    \"\"\"\n    # create the space for the simulation\n    space = self._define_space(\n        dims=self.simulation_config.Global_Parameters.field_of_view_dim,\n        movie_frames=self.frame_count,\n    )\n    # create the tracks and points_per_time\n    tracks, points_per_time = self._create_track_pop_dict(space)\n    points_per_frame = self._point_per_time_selection(points_per_time)\n\n    # update the space\n    space_updated = self._create_map(\n        initial_map=space,\n        points_per_frame=points_per_frame,\n        axial_function=self.simulation_config.Global_Parameters.axial_function,\n    )\n    return {\n        \"map\": space_updated,\n        \"tracks\": tracks,\n        \"points_per_frame\": points_per_frame,\n    }\n</code></pre>"},{"location":"simulate_cell_reference/#SMS_BP.simulate_cell.convert_arrays_to_lists","title":"<code>convert_arrays_to_lists(obj)</code>","text":"<p>Recursively convert NumPy arrays to lists.</p>"},{"location":"simulate_cell_reference/#SMS_BP.simulate_cell.convert_arrays_to_lists--parameters","title":"Parameters:","text":"<p>obj : np.ndarray | dict     Object to be converted.</p>"},{"location":"simulate_cell_reference/#SMS_BP.simulate_cell.convert_arrays_to_lists--returns","title":"Returns:","text":"<p>list | dict     Converted object with NumPy arrays replaced by lists.</p> Source code in <code>SMS_BP/simulate_cell.py</code> <pre><code>def convert_arrays_to_lists(obj: np.ndarray | dict) -&gt; list | dict:\n    \"\"\"\n    Recursively convert NumPy arrays to lists.\n\n    Parameters:\n    -----------\n    obj : np.ndarray | dict\n        Object to be converted.\n\n    Returns:\n    --------\n    list | dict\n        Converted object with NumPy arrays replaced by lists.\n    \"\"\"\n    if isinstance(obj, np.ndarray):\n        return obj.tolist()\n    elif isinstance(obj, dict):\n        return {k: convert_arrays_to_lists(v) for k, v in obj.items()}\n    else:\n        return obj\n</code></pre>"},{"location":"simulate_cell_reference/#SMS_BP.simulate_cell.convert_lists_to_arrays","title":"<code>convert_lists_to_arrays(obj)</code>","text":"<p>Recursively convert lists to NumPy arrays.</p>"},{"location":"simulate_cell_reference/#SMS_BP.simulate_cell.convert_lists_to_arrays--parameters","title":"Parameters:","text":"<p>obj : list | dict     Object to be converted.</p>"},{"location":"simulate_cell_reference/#SMS_BP.simulate_cell.convert_lists_to_arrays--returns","title":"Returns:","text":"<p>np.ndarray | dict     Converted object with lists replaced by NumPy arrays.</p> Source code in <code>SMS_BP/simulate_cell.py</code> <pre><code>def convert_lists_to_arrays(obj: list | dict) -&gt; np.ndarray | dict:\n    \"\"\"\n    Recursively convert lists to NumPy arrays.\n\n    Parameters:\n    -----------\n    obj : list | dict\n        Object to be converted.\n\n    Returns:\n    --------\n    np.ndarray | dict\n        Converted object with lists replaced by NumPy arrays.\n    \"\"\"\n    if isinstance(obj, list):\n        return np.array(obj)\n    elif isinstance(obj, dict):\n        return {k: convert_lists_to_arrays(v) for k, v in obj.items()}\n    else:\n        return obj\n</code></pre>"},{"location":"simulate_cell_reference/#SMS_BP.simulate_cell.make_directory_structure","title":"<code>make_directory_structure(cd, img_name, img, subsegment_type, subsegment_num, **kwargs)</code>","text":"<p>Create the directory structure for the simulation, save the image, and perform subsegmentation.</p>"},{"location":"simulate_cell_reference/#SMS_BP.simulate_cell.make_directory_structure--parameters","title":"Parameters:","text":"<p>cd : str     Directory where the simulation will be saved. img_name : str     Name of the image. img : np.ndarray     Image to be subsegmented. subsegment_type : str     Type of subsegmentation to be performed. subsegment_num : int     Number of subsegments to be created. **kwargs : dict     Additional keyword arguments, including:     - data : dict (optional)         Dictionary of data to be saved, keys are \"map\", \"tracks\", \"points_per_frame\".     - parameters : dict (optional)         Parameters of the simulation to be saved.</p>"},{"location":"simulate_cell_reference/#SMS_BP.simulate_cell.make_directory_structure--returns","title":"Returns:","text":"<p>list[np.ndarray]     List of subsegmented images.</p>"},{"location":"simulate_cell_reference/#SMS_BP.simulate_cell.make_directory_structure--raises","title":"Raises:","text":"<p>None</p> Source code in <code>SMS_BP/simulate_cell.py</code> <pre><code>def make_directory_structure(\n    cd: str,\n    img_name: str,\n    img: np.ndarray,\n    subsegment_type: str,\n    subsegment_num: int,\n    **kwargs,\n) -&gt; list[np.ndarray]:\n    \"\"\"\n    Create the directory structure for the simulation, save the image, and perform subsegmentation.\n\n    Parameters:\n    -----------\n    cd : str\n        Directory where the simulation will be saved.\n    img_name : str\n        Name of the image.\n    img : np.ndarray\n        Image to be subsegmented.\n    subsegment_type : str\n        Type of subsegmentation to be performed.\n    subsegment_num : int\n        Number of subsegments to be created.\n    **kwargs : dict\n        Additional keyword arguments, including:\n        - data : dict (optional)\n            Dictionary of data to be saved, keys are \"map\", \"tracks\", \"points_per_frame\".\n        - parameters : dict (optional)\n            Parameters of the simulation to be saved.\n\n    Returns:\n    --------\n    list[np.ndarray]\n        List of subsegmented images.\n\n    Raises:\n    -------\n    None\n    \"\"\"\n    # make the directory if it does not exist\n    if not os.path.exists(cd):\n        os.makedirs(cd)\n    # track_pickle\n    track_pickle = os.path.join(cd, \"Track_dump.pkl\")\n    # params_pickle\n    params_pickle = os.path.join(cd, \"params_dump.pkl\")\n    # params_json\n    params_json = os.path.join(cd, \"params_dump.json\")\n\n    # saves the data if it is passed as a keyword argument (map,tracks,points_per_frame)\n    with open(track_pickle, \"wb+\") as f:\n        pickle.dump(kwargs.get(\"data\", {}), f)\n    # saves the parameters used to generate the simulation\n    with open(params_pickle, \"wb+\") as f:\n        pickle.dump(kwargs.get(\"parameters\", {}), f)\n\n    # in this directory, dump the parameters into a json file\n    with open(params_json, \"w\") as f:\n        # dump the parameters into a json file\n        json.dump(convert_arrays_to_lists(kwargs.get(\"parameters\", {})), f)\n        # json.dump({}, f)\n\n    # make a diretory inside cd called Analysis if it does not exist\n    if not os.path.exists(os.path.join(cd, \"Analysis\")):\n        os.makedirs(os.path.join(cd, \"Analysis\"))\n    # save the img file with its name in the cd directory\n    save_tiff(img, cd, img_name=img_name)\n    # make a directory inside cd called segmented if it does not exist\n    if not os.path.exists(os.path.join(cd, \"segmented\")):\n        os.makedirs(os.path.join(cd, \"segmented\"))\n    # perform subsegmentation on the image\n    hold_img = sub_segment(\n        img, subsegment_num, img_name=img_name, subsegment_type=subsegment_type\n    )\n    # create the names for the subsegmented images\n    hold_name = []\n    for i in np.arange(subsegment_num):\n        hold_name.append(\n            os.path.join(cd, \"segmented\", str(int(i) + 1) + \"_\" + img_name + \".tif\")\n        )\n    # save the subsegmented images\n    for i in np.arange(subsegment_num):\n        img = Image.fromarray(hold_img[i])\n        img.save(hold_name[i])\n    return hold_img\n</code></pre>"},{"location":"simulate_cell_reference/#SMS_BP.simulate_cell.save_tiff","title":"<code>save_tiff(image, path, img_name=None)</code>","text":"<p>Save the image as a TIFF file.</p>"},{"location":"simulate_cell_reference/#SMS_BP.simulate_cell.save_tiff--parameters","title":"Parameters:","text":"<p>image : np.ndarray     Image to be saved. path : str     Path where the image will be saved. img_name : str, optional     Name of the image file (without extension), by default None.</p>"},{"location":"simulate_cell_reference/#SMS_BP.simulate_cell.save_tiff--returns","title":"Returns:","text":"<p>None</p> Source code in <code>SMS_BP/simulate_cell.py</code> <pre><code>def save_tiff(image: np.ndarray, path: str, img_name: str | None = None) -&gt; None:\n    \"\"\"\n    Save the image as a TIFF file.\n\n    Parameters:\n    -----------\n    image : np.ndarray\n        Image to be saved.\n    path : str\n        Path where the image will be saved.\n    img_name : str, optional\n        Name of the image file (without extension), by default None.\n\n    Returns:\n    --------\n    None\n    \"\"\"\n    if img_name is None:\n        skimage.io.imsave(path, image)\n    else:\n        skimage.io.imsave(os.path.join(path, img_name + \".tiff\"), image)\n    return\n</code></pre>"},{"location":"simulate_cell_reference/#SMS_BP.simulate_cell.sub_segment","title":"<code>sub_segment(img, subsegment_num, img_name=None, subsegment_type='mean')</code>","text":"<p>Perform subsegmentation on the image.</p>"},{"location":"simulate_cell_reference/#SMS_BP.simulate_cell.sub_segment--parameters","title":"Parameters:","text":"<p>img : np.ndarray     Image to be subsegmented. subsegment_num : int     Number of subsegments to be created. img_name : str, optional     Name of the image, by default None. subsegment_type : str, optional     Type of subsegmentation to be performed. Options are \"mean\", \"max\", \"std\". Default is \"mean\".</p>"},{"location":"simulate_cell_reference/#SMS_BP.simulate_cell.sub_segment--returns","title":"Returns:","text":"<p>list[np.ndarray]     List of subsegmented images.</p>"},{"location":"simulate_cell_reference/#SMS_BP.simulate_cell.sub_segment--raises","title":"Raises:","text":"<p>ValueError     If the subsegment type is not supported.</p> Source code in <code>SMS_BP/simulate_cell.py</code> <pre><code>def sub_segment(\n    img: np.ndarray,\n    subsegment_num: int,\n    img_name: str | None = None,\n    subsegment_type: str = \"mean\",\n) -&gt; list[np.ndarray]:\n    \"\"\"\n    Perform subsegmentation on the image.\n\n    Parameters:\n    -----------\n    img : np.ndarray\n        Image to be subsegmented.\n    subsegment_num : int\n        Number of subsegments to be created.\n    img_name : str, optional\n        Name of the image, by default None.\n    subsegment_type : str, optional\n        Type of subsegmentation to be performed. Options are \"mean\", \"max\", \"std\". Default is \"mean\".\n\n    Returns:\n    --------\n    list[np.ndarray]\n        List of subsegmented images.\n\n    Raises:\n    -------\n    ValueError\n        If the subsegment type is not supported.\n    \"\"\"\n    supported_subsegment_types = [\"mean\", \"max\", \"std\"]\n    if subsegment_type not in supported_subsegment_types:\n        raise ValueError(\n            f\"Subsegment type {subsegment_type} is not supported. Supported types are {supported_subsegment_types}\"\n        )\n    # get the dimensions of the image\n    dims = img.shape\n    # get the number of frames\n    num_frames = dims[0]\n    # find the number of frames per subsegment\n    frames_per_subsegment = int(num_frames / subsegment_num)\n    hold_img = []\n    for j in np.arange(subsegment_num):\n        if subsegment_type == \"mean\":\n            hold_img.append(\n                np.mean(\n                    img[\n                        int(j * frames_per_subsegment) : int(\n                            (j + 1) * frames_per_subsegment\n                        )\n                    ],\n                    axis=0,\n                )\n            )\n        elif subsegment_type == \"max\":\n            hold_img.append(\n                np.max(\n                    img[\n                        int(j * frames_per_subsegment) : int(\n                            (j + 1) * frames_per_subsegment\n                        )\n                    ],\n                    axis=0,\n                )\n            )\n        elif subsegment_type == \"std\":\n            hold_img.append(\n                np.std(\n                    img[\n                        int(j * frames_per_subsegment) : int(\n                            (j + 1) * frames_per_subsegment\n                        )\n                    ],\n                    axis=0,\n                )\n            )\n    return hold_img\n</code></pre>"},{"location":"simulate_foci_reference/","title":"Simulate Foci","text":""},{"location":"simulate_foci_reference/#simulate_foci_reference","title":"Simulate Foci Reference","text":""},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci--simulate_focipy","title":"simulate_foci.py","text":"<p>This file contains the necessary classes and functions to simulate foci dynamics in space, particularly within cell simulations.</p> <p>Author: Baljyot Singh Parmar</p>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci--classes","title":"Classes:","text":"<ul> <li>Track_generator: A class to generate tracks of foci movements in a cell space with or without transitions.</li> </ul>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci--functions","title":"Functions:","text":"<ul> <li>get_lengths: Generates an array of track lengths based on a chosen distribution.</li> <li>create_condensate_dict: Creates a dictionary of condensates for simulation.</li> <li>tophat_function_2d: Defines a circular top-hat probability distribution in 2D.</li> <li>generate_points: Generates random points following a given probability distribution.</li> <li>generate_points_from_cls: Generates 3D points using the accept/reject method based on a given distribution.</li> <li>generate_radial_points: Generates uniformly distributed points in a circle.</li> <li>generate_sphere_points: Generates uniformly distributed points in a sphere.</li> <li>radius_spherical_cap: Computes the radius of a spherical cap given the sphere's radius and a z-slice.</li> <li>get_gaussian: Returns a 2D Gaussian distribution over a given domain.</li> <li>axial_intensity_factor: Computes the axial intensity factor based on axial position.</li> <li>generate_map_from_points: Generates a spatial map from given points and intensities.</li> </ul>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.Track_generator","title":"<code>Track_generator</code>","text":"<p>A class to generate tracks of foci movements in a simulated cell space.</p>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.Track_generator--parameters","title":"Parameters:","text":"<p>cell : BaseCell     Cell object defining the space for track generation oversample_motion_time : int | float     Time for oversampling motion in milliseconds.</p> Source code in <code>SMS_BP/simulate_foci.py</code> <pre><code>class Track_generator:\n    \"\"\"\n    A class to generate tracks of foci movements in a simulated cell space.\n\n    Parameters:\n    -----------\n    cell : BaseCell\n        Cell object defining the space for track generation\n    oversample_motion_time : int | float\n        Time for oversampling motion in milliseconds.\n    \"\"\"\n\n    def __init__(\n        self,\n        cell: BaseCell,\n        total_time: int | float,\n        oversample_motion_time: int | float,\n    ) -&gt; None:\n        self.cell = cell\n        self._allowable_cell_types()\n\n        self.oversample_motion_time = oversample_motion_time  # in ms\n        # total time in ms is the exposure time + interval time * (cycle_count) / oversample_motion_time\n        # in ms\n        self.total_time = total_time\n\n    def _allowable_cell_types(self):\n        # only allow rectangular cells for now\n        # if not isinstance(self.cell, RectangularCell):\n        #     raise ValueError(\n        #         \"Only rectangular cells are supported for track generation\"\n        #     )\n        pass\n\n    def track_generation_no_transition(\n        self,\n        diffusion_coefficient: float,  # um^2/s\n        hurst_exponent: float,\n        track_length: int,\n        initials: np.ndarray,\n        start_time: int | float,\n    ) -&gt; dict:\n        \"\"\"\n        Simulates the track generation with no transition between the diffusion coefficients and the hurst exponents\n        namely, this means each track has a unique diffusion coefficient and hurst exponent\n        This simulation is confined to the cell space and the axial range of the cell\n\n        Parameters:\n        -----------\n        diffusion_coefficient : float\n            diffusion coefficient for the track\n        hurst_exponent : float\n            hurst exponent for the track\n        track_length : int\n            track_length for the track\n        initials : array-like\n            [[x,y,z]] coordinates of the initial positions of the track\n        start_time : int\n            time at which the track start (this is not the frame, and needs to be converted to the frame using the exposure time and interval time and the oversample motion time)\n        Returns:\n        --------\n        dict-like with format: {\"xy\":xyz,\"times\":times,\"diffusion_coefficient\":diffusion_coefficient,\"hurst\":hurst_exponent,\"initial\":initial}\n        \"\"\"\n        # initialize the fbm class\n        # make self.space_lim relative to the initial position, using self.space_lim define the 0 to be initial position\n        if np.shape(initials) == (2,):\n            # change the shape to (3,)\n            initials = np.array([initials[0], initials[1], 0])\n        # convert the diffusion_coefficients\n        # diffusion_coefficient = self._convert_diffcoef_um2s_um2xms(\n        #     diffusion_coefficient\n        # )\n        fbm = FBM_BP(\n            n=track_length,\n            dt=self.oversample_motion_time / 1000.0,\n            hurst_parameters=[hurst_exponent],\n            diffusion_parameters=[diffusion_coefficient],\n            diffusion_parameter_transition_matrix=[1],\n            hurst_parameter_transition_matrix=[1],\n            state_probability_diffusion=[1],\n            state_probability_hurst=[1],\n            cell=self.cell,\n            initial_position=initials,\n        )\n        xyz = fbm.fbm(dims=3)\n        # make the times starting from the starting time\n        track_times = np.arange(\n            start_time,\n            (track_length + start_time),\n            1,\n        )\n        track_xyz = xyz\n        # create the dict\n        track_data = {\n            \"xy\": track_xyz,\n            \"times\": track_times,\n            \"diffusion_coefficient\": fbm._diff_a_n,\n            \"hurst\": fbm._hurst_n,\n            \"initial\": initials,\n        }\n        # construct the dict\n        return track_data\n\n    def track_generation_with_transition(\n        self,\n        diffusion_transition_matrix: np.ndarray | list,\n        hurst_transition_matrix: np.ndarray | list,\n        diffusion_parameters: np.ndarray | list,  # um^2/s\n        hurst_parameters: np.ndarray | list,\n        diffusion_state_probability: np.ndarray | list,\n        hurst_state_probability: np.ndarray | list,\n        track_length: int,\n        initials: np.ndarray,\n        start_time: int | float,\n    ) -&gt; dict:\n        \"\"\"\n        Genereates the track data with transition between the diffusion coefficients and the hurst exponents\n\n        Parameters:\n        -----------\n        diffusion_transition_matrix : array-like\n            transition matrix for the diffusion coefficients\n        hurst_transition_matrix : array-like\n            transition matrix for the hurst exponents\n        diffusion_parameters : array-like\n            diffusion coefficients for the tracks\n        hurst_parameters : array-like\n            hurst exponents for the tracks\n        diffusion_state_probability : array-like\n            probabilities for the diffusion coefficients\n        hurst_state_probability : array-like\n            probabilities for the hurst exponents\n        track_length : int\n            track_length for the track\n        initials : array-like\n            [[x,y,z]] coordinates of the initial positions of the track\n        start_time : int\n            time at which the track start (this is not the frame, and needs to be converted to the frame using the exposure time and interval time and the oversample motion time)\n\n        Returns:\n        --------\n        dict-like with format: {\"xy\":xyz,\"times\":times,\"diffusion_coefficient\":diffusion_coefficient,\"hurst\":hurst_exponent,\"initial\":initial}\n        \"\"\"\n        # make self.space_lim relative to the initial position, using self.space_lim define the 0 to be initial position\n        # self.space_lim is in general shape (3,2) while the initials is in shape (3,)\n        # make sure the - operator is broadcasted correctly\n        if np.shape(initials) == (2,):\n            # change the shape to (3,)\n            initials = np.array([initials[0], initials[1], 0])\n        # subtract each element of the first dimension of self.space_lim by the first element of initials\n\n        # convert the diffusion_coefficients\n        # diffusion_parameters = self._convert_diffcoef_um2s_um2xms(diffusion_parameters)\n        # initialize the fbm class\n        fbm = FBM_BP(\n            n=track_length,\n            dt=self.oversample_motion_time / 1000.0,\n            hurst_parameters=hurst_parameters,\n            diffusion_parameters=diffusion_parameters,\n            diffusion_parameter_transition_matrix=diffusion_transition_matrix,\n            hurst_parameter_transition_matrix=hurst_transition_matrix,\n            state_probability_diffusion=diffusion_state_probability,\n            state_probability_hurst=hurst_state_probability,\n            cell=self.cell,\n            initial_position=initials,\n        )\n        xyz = fbm.fbm(dims=3)\n        # make the times starting from the starting time\n        track_times = np.arange(\n            start_time,\n            track_length + start_time,\n            1,\n        )\n        track_xyz = xyz\n        # create the dict\n        track_data = {\n            \"xy\": track_xyz,\n            \"times\": track_times,\n            \"diffusion_coefficient\": fbm._diff_a_n,\n            \"hurst\": fbm._hurst_n,\n            \"initial\": initials,\n        }\n        # construct the dict\n        return track_data\n\n    def track_generation_constant(\n        self, track_length: int, initials: np.ndarray, start_time: int\n    ) -&gt; dict:\n        \"\"\"\n        Generate a constant track (no movement).\n\n        Parameters:\n        -----------\n        track_length : int\n            mean track length, in this case the track length is constant with this mean\n        initials : array-like\n            [[x,y,z]] coordinates of the initial positions of the track\n        starting_time : int\n            time at which the track start (this is not the frame, and needs to be converted to the frame using the exposure time and interval time and the oversample motion time)\n\n        Returns:\n        --------\n        dict-like with format: {\"xy\":xyz,\"times\":times,\"diffusion_coefficient\":diffusion_coefficient,\"hurst\":hurst_exponent,\"initial\":initial}\n        \"\"\"\n        # make the times starting from the starting time\n        track_times = np.arange(\n            start_time,\n            track_length + start_time,\n            1,\n        )\n        # make the track x,y,z from the initial positions\n        track_xyz = np.tile(initials, (len(track_times), 1))\n        # construct the dict\n        track_data = {\n            \"xy\": track_xyz,\n            \"times\": track_times,\n            \"diffusion_coefficient\": 0,\n            \"hurst\": 0,\n            \"initial\": initials,\n        }\n        return track_data\n\n    @overload\n    def _convert_diffcoef_um2s_um2xms(self, diffusion_coefficient: float) -&gt; float: ...\n    @overload\n    def _convert_diffcoef_um2s_um2xms(\n        self, diffusion_coefficient: np.ndarray\n    ) -&gt; np.ndarray: ...\n    @overload\n    def _convert_diffcoef_um2s_um2xms(self, diffusion_coefficient: list) -&gt; list: ...\n    def _convert_diffcoef_um2s_um2xms(\n        self, diffusion_coefficient: float | np.ndarray | list\n    ) -&gt; float | np.ndarray | list:\n        \"\"\"converts um^2/s diffusion_coefficient into um^2/ x ms\n        x = amount of ms\n        ms = milliseconds\n\n        x ms = self.oversample_motion_time (in ms, int)\"\"\"\n        if isinstance(diffusion_coefficient, (np.ndarray, float)):\n            return (\n                1.0 / (1000.0 / self.oversample_motion_time)\n            ) * diffusion_coefficient\n        elif isinstance(diffusion_coefficient, list):\n            return [\n                (1.0 / (1000.0 / self.oversample_motion_time)) * i\n                for i in diffusion_coefficient\n            ]\n        else:\n            raise TypeError(f\"Unsupported type: {type(diffusion_coefficient)}\")\n\n    def _convert_time_to_frame(\n        self, time: int, exposure_time: int, interval_time: int\n    ) -&gt; int:\n        \"\"\"\n        Parameters:\n        -----------\n        time : int\n            time in ms\n\n        Returns:\n        --------\n        int: frame number\n        \"\"\"\n        return int(\n            (time * self.oversample_motion_time) / (exposure_time + interval_time)\n        )\n\n    def _convert_frame_to_time(\n        self, frame: int, exposure_time: int, interval_time: int\n    ) -&gt; int:\n        \"\"\"\n        Parameters:\n        -----------\n        frame : int\n            frame number\n\n        Returns:\n        --------\n        int: time in ms\n        \"\"\"\n        return int((frame * (exposure_time + interval_time)))\n</code></pre>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.Track_generator.track_generation_constant","title":"<code>track_generation_constant(track_length, initials, start_time)</code>","text":"<p>Generate a constant track (no movement).</p>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.Track_generator.track_generation_constant--parameters","title":"Parameters:","text":"<p>track_length : int     mean track length, in this case the track length is constant with this mean initials : array-like     [[x,y,z]] coordinates of the initial positions of the track starting_time : int     time at which the track start (this is not the frame, and needs to be converted to the frame using the exposure time and interval time and the oversample motion time)</p>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.Track_generator.track_generation_constant--returns","title":"Returns:","text":"<p>dict-like with format: {\"xy\":xyz,\"times\":times,\"diffusion_coefficient\":diffusion_coefficient,\"hurst\":hurst_exponent,\"initial\":initial}</p> Source code in <code>SMS_BP/simulate_foci.py</code> <pre><code>def track_generation_constant(\n    self, track_length: int, initials: np.ndarray, start_time: int\n) -&gt; dict:\n    \"\"\"\n    Generate a constant track (no movement).\n\n    Parameters:\n    -----------\n    track_length : int\n        mean track length, in this case the track length is constant with this mean\n    initials : array-like\n        [[x,y,z]] coordinates of the initial positions of the track\n    starting_time : int\n        time at which the track start (this is not the frame, and needs to be converted to the frame using the exposure time and interval time and the oversample motion time)\n\n    Returns:\n    --------\n    dict-like with format: {\"xy\":xyz,\"times\":times,\"diffusion_coefficient\":diffusion_coefficient,\"hurst\":hurst_exponent,\"initial\":initial}\n    \"\"\"\n    # make the times starting from the starting time\n    track_times = np.arange(\n        start_time,\n        track_length + start_time,\n        1,\n    )\n    # make the track x,y,z from the initial positions\n    track_xyz = np.tile(initials, (len(track_times), 1))\n    # construct the dict\n    track_data = {\n        \"xy\": track_xyz,\n        \"times\": track_times,\n        \"diffusion_coefficient\": 0,\n        \"hurst\": 0,\n        \"initial\": initials,\n    }\n    return track_data\n</code></pre>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.Track_generator.track_generation_no_transition","title":"<code>track_generation_no_transition(diffusion_coefficient, hurst_exponent, track_length, initials, start_time)</code>","text":"<p>Simulates the track generation with no transition between the diffusion coefficients and the hurst exponents namely, this means each track has a unique diffusion coefficient and hurst exponent This simulation is confined to the cell space and the axial range of the cell</p>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.Track_generator.track_generation_no_transition--parameters","title":"Parameters:","text":"<p>diffusion_coefficient : float     diffusion coefficient for the track hurst_exponent : float     hurst exponent for the track track_length : int     track_length for the track initials : array-like     [[x,y,z]] coordinates of the initial positions of the track start_time : int     time at which the track start (this is not the frame, and needs to be converted to the frame using the exposure time and interval time and the oversample motion time) Returns:</p> <p>dict-like with format: {\"xy\":xyz,\"times\":times,\"diffusion_coefficient\":diffusion_coefficient,\"hurst\":hurst_exponent,\"initial\":initial}</p> Source code in <code>SMS_BP/simulate_foci.py</code> <pre><code>def track_generation_no_transition(\n    self,\n    diffusion_coefficient: float,  # um^2/s\n    hurst_exponent: float,\n    track_length: int,\n    initials: np.ndarray,\n    start_time: int | float,\n) -&gt; dict:\n    \"\"\"\n    Simulates the track generation with no transition between the diffusion coefficients and the hurst exponents\n    namely, this means each track has a unique diffusion coefficient and hurst exponent\n    This simulation is confined to the cell space and the axial range of the cell\n\n    Parameters:\n    -----------\n    diffusion_coefficient : float\n        diffusion coefficient for the track\n    hurst_exponent : float\n        hurst exponent for the track\n    track_length : int\n        track_length for the track\n    initials : array-like\n        [[x,y,z]] coordinates of the initial positions of the track\n    start_time : int\n        time at which the track start (this is not the frame, and needs to be converted to the frame using the exposure time and interval time and the oversample motion time)\n    Returns:\n    --------\n    dict-like with format: {\"xy\":xyz,\"times\":times,\"diffusion_coefficient\":diffusion_coefficient,\"hurst\":hurst_exponent,\"initial\":initial}\n    \"\"\"\n    # initialize the fbm class\n    # make self.space_lim relative to the initial position, using self.space_lim define the 0 to be initial position\n    if np.shape(initials) == (2,):\n        # change the shape to (3,)\n        initials = np.array([initials[0], initials[1], 0])\n    # convert the diffusion_coefficients\n    # diffusion_coefficient = self._convert_diffcoef_um2s_um2xms(\n    #     diffusion_coefficient\n    # )\n    fbm = FBM_BP(\n        n=track_length,\n        dt=self.oversample_motion_time / 1000.0,\n        hurst_parameters=[hurst_exponent],\n        diffusion_parameters=[diffusion_coefficient],\n        diffusion_parameter_transition_matrix=[1],\n        hurst_parameter_transition_matrix=[1],\n        state_probability_diffusion=[1],\n        state_probability_hurst=[1],\n        cell=self.cell,\n        initial_position=initials,\n    )\n    xyz = fbm.fbm(dims=3)\n    # make the times starting from the starting time\n    track_times = np.arange(\n        start_time,\n        (track_length + start_time),\n        1,\n    )\n    track_xyz = xyz\n    # create the dict\n    track_data = {\n        \"xy\": track_xyz,\n        \"times\": track_times,\n        \"diffusion_coefficient\": fbm._diff_a_n,\n        \"hurst\": fbm._hurst_n,\n        \"initial\": initials,\n    }\n    # construct the dict\n    return track_data\n</code></pre>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.Track_generator.track_generation_with_transition","title":"<code>track_generation_with_transition(diffusion_transition_matrix, hurst_transition_matrix, diffusion_parameters, hurst_parameters, diffusion_state_probability, hurst_state_probability, track_length, initials, start_time)</code>","text":"<p>Genereates the track data with transition between the diffusion coefficients and the hurst exponents</p>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.Track_generator.track_generation_with_transition--parameters","title":"Parameters:","text":"<p>diffusion_transition_matrix : array-like     transition matrix for the diffusion coefficients hurst_transition_matrix : array-like     transition matrix for the hurst exponents diffusion_parameters : array-like     diffusion coefficients for the tracks hurst_parameters : array-like     hurst exponents for the tracks diffusion_state_probability : array-like     probabilities for the diffusion coefficients hurst_state_probability : array-like     probabilities for the hurst exponents track_length : int     track_length for the track initials : array-like     [[x,y,z]] coordinates of the initial positions of the track start_time : int     time at which the track start (this is not the frame, and needs to be converted to the frame using the exposure time and interval time and the oversample motion time)</p>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.Track_generator.track_generation_with_transition--returns","title":"Returns:","text":"<p>dict-like with format: {\"xy\":xyz,\"times\":times,\"diffusion_coefficient\":diffusion_coefficient,\"hurst\":hurst_exponent,\"initial\":initial}</p> Source code in <code>SMS_BP/simulate_foci.py</code> <pre><code>def track_generation_with_transition(\n    self,\n    diffusion_transition_matrix: np.ndarray | list,\n    hurst_transition_matrix: np.ndarray | list,\n    diffusion_parameters: np.ndarray | list,  # um^2/s\n    hurst_parameters: np.ndarray | list,\n    diffusion_state_probability: np.ndarray | list,\n    hurst_state_probability: np.ndarray | list,\n    track_length: int,\n    initials: np.ndarray,\n    start_time: int | float,\n) -&gt; dict:\n    \"\"\"\n    Genereates the track data with transition between the diffusion coefficients and the hurst exponents\n\n    Parameters:\n    -----------\n    diffusion_transition_matrix : array-like\n        transition matrix for the diffusion coefficients\n    hurst_transition_matrix : array-like\n        transition matrix for the hurst exponents\n    diffusion_parameters : array-like\n        diffusion coefficients for the tracks\n    hurst_parameters : array-like\n        hurst exponents for the tracks\n    diffusion_state_probability : array-like\n        probabilities for the diffusion coefficients\n    hurst_state_probability : array-like\n        probabilities for the hurst exponents\n    track_length : int\n        track_length for the track\n    initials : array-like\n        [[x,y,z]] coordinates of the initial positions of the track\n    start_time : int\n        time at which the track start (this is not the frame, and needs to be converted to the frame using the exposure time and interval time and the oversample motion time)\n\n    Returns:\n    --------\n    dict-like with format: {\"xy\":xyz,\"times\":times,\"diffusion_coefficient\":diffusion_coefficient,\"hurst\":hurst_exponent,\"initial\":initial}\n    \"\"\"\n    # make self.space_lim relative to the initial position, using self.space_lim define the 0 to be initial position\n    # self.space_lim is in general shape (3,2) while the initials is in shape (3,)\n    # make sure the - operator is broadcasted correctly\n    if np.shape(initials) == (2,):\n        # change the shape to (3,)\n        initials = np.array([initials[0], initials[1], 0])\n    # subtract each element of the first dimension of self.space_lim by the first element of initials\n\n    # convert the diffusion_coefficients\n    # diffusion_parameters = self._convert_diffcoef_um2s_um2xms(diffusion_parameters)\n    # initialize the fbm class\n    fbm = FBM_BP(\n        n=track_length,\n        dt=self.oversample_motion_time / 1000.0,\n        hurst_parameters=hurst_parameters,\n        diffusion_parameters=diffusion_parameters,\n        diffusion_parameter_transition_matrix=diffusion_transition_matrix,\n        hurst_parameter_transition_matrix=hurst_transition_matrix,\n        state_probability_diffusion=diffusion_state_probability,\n        state_probability_hurst=hurst_state_probability,\n        cell=self.cell,\n        initial_position=initials,\n    )\n    xyz = fbm.fbm(dims=3)\n    # make the times starting from the starting time\n    track_times = np.arange(\n        start_time,\n        track_length + start_time,\n        1,\n    )\n    track_xyz = xyz\n    # create the dict\n    track_data = {\n        \"xy\": track_xyz,\n        \"times\": track_times,\n        \"diffusion_coefficient\": fbm._diff_a_n,\n        \"hurst\": fbm._hurst_n,\n        \"initial\": initials,\n    }\n    # construct the dict\n    return track_data\n</code></pre>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.axial_intensity_factor","title":"<code>axial_intensity_factor(abs_axial_pos, detection_range, **kwargs)</code>","text":"<p>Docstring Calculate the factor for the axial intensity of the PSF given the absolute axial position from the 0 position of the focal plane. This is the factor that is multiplied by the intensity of the PSF</p> <p>For now this is a negative exponential decay i.e:     I = I_0e^(-|z-z_0|) This function returns the factor e^(-|z-z_0|2 / (22.2**2)) only.</p>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.axial_intensity_factor--parameters","title":"Parameters:","text":"<p>abs_axial_pos : float|np.ndarray     absolute axial position from the 0 position of the focal plane detection_range : float     detection range of the function. This is the standard deviation of the gaussian function describing the axial intensity decay assuming a gaussian function. kwargs : dict</p>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.axial_intensity_factor--returns","title":"Returns:","text":"<p>float|np.ndarray     factor for the axial intensity of the PSF</p> Source code in <code>SMS_BP/simulate_foci.py</code> <pre><code>def axial_intensity_factor(\n    abs_axial_pos: float | np.ndarray, detection_range: float, **kwargs\n) -&gt; float | np.ndarray:\n    \"\"\"Docstring\n    Calculate the factor for the axial intensity of the PSF given the absolute axial position from the 0 position of\n    the focal plane. This is the factor that is multiplied by the intensity of the PSF\n\n    For now this is a negative exponential decay i.e:\n        I = I_0*e^(-|z-z_0|)\n    This function returns the factor e^(-|z-z_0|**2 / (2*2.2**2)) only.\n\n    Parameters:\n    -----------\n    abs_axial_pos : float|np.ndarray\n        absolute axial position from the 0 position of the focal plane\n    detection_range : float\n        detection range of the function. This is the standard deviation of the gaussian function describing the axial intensity decay assuming a gaussian function.\n    kwargs : dict\n\n    Returns:\n    --------\n    float|np.ndarray\n        factor for the axial intensity of the PSF\n    \"\"\"\n    func_type = kwargs.get(\"func\", \"ones\")\n    if func_type == \"ones\":\n        try:\n            return np.ones(len(abs_axial_pos))\n        except Exception:\n            return 1\n    elif func_type == \"exponential\":\n        # for now this uses a negative exponential decay\n        return np.exp(-(abs_axial_pos**2) / (2 * detection_range**2))\n</code></pre>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.generate_map_from_points","title":"<code>generate_map_from_points(points, point_intensity, map, movie, base_noise, psf_sigma)</code>","text":"<p>Generates a 2D spatial map from a set of points and their intensities.</p>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.generate_map_from_points--parameters","title":"Parameters:","text":"<p>points : np.ndarray     Array of points of shape (total_points, 2). point_intensity : float | np.ndarray     Intensity of the points. map : np.ndarray     Pre-defined space map to update. If None, a new map is generated. movie : bool     If True, noise is added to the whole image at once; otherwise, noise is added per point. base_noise : float     Base noise level to add to the spatial map. psf_sigma : float     Sigma of the PSF (in pixel units).</p>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.generate_map_from_points--returns","title":"Returns:","text":"<p>tuple[np.ndarray, np.ndarray]     The updated spatial map and the points.</p> Source code in <code>SMS_BP/simulate_foci.py</code> <pre><code>def generate_map_from_points(\n    points: np.ndarray,\n    point_intensity: float | np.ndarray,\n    map: np.ndarray,\n    movie: bool,\n    base_noise: float,\n    psf_sigma: float,\n) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Generates a 2D spatial map from a set of points and their intensities.\n\n    Parameters:\n    -----------\n    points : np.ndarray\n        Array of points of shape (total_points, 2).\n    point_intensity : float | np.ndarray\n        Intensity of the points.\n    map : np.ndarray\n        Pre-defined space map to update. If None, a new map is generated.\n    movie : bool\n        If True, noise is added to the whole image at once; otherwise, noise is added per point.\n    base_noise : float\n        Base noise level to add to the spatial map.\n    psf_sigma : float\n        Sigma of the PSF (in pixel units).\n\n    Returns:\n    --------\n    tuple[np.ndarray, np.ndarray]\n        The updated spatial map and the points.\n    \"\"\"\n\n    space_map = map\n    x = np.arange(0, np.shape(map)[0], 1.0)\n    y = np.arange(0, np.shape(map)[1], 1.0)\n\n    if np.isscalar(point_intensity):\n        point_intensity *= np.ones(len(points))\n\n    if point_intensity is None:\n        for i, j in enumerate(points):\n            space_map += get_gaussian(j, np.ones(2) * psf_sigma, domain=[x, y])\n    else:\n        for i, j in enumerate(points):\n            gauss_probability = get_gaussian(j, np.ones(2) * psf_sigma, domain=[x, y])\n            # normalize\n            gauss_probability = gauss_probability / np.max(gauss_probability)\n\n            # generate poisson process over this space using the gaussian probability as means\n            if not movie:\n                space_map += np.random.poisson(\n                    gauss_probability * point_intensity[i] + base_noise,\n                    size=(len(x), len(y)),\n                )\n            else:\n                space_map += gauss_probability * point_intensity[i]\n        if movie:\n            intensity = np.random.poisson(space_map + base_noise, size=(len(x), len(y)))\n            space_map = intensity\n    return space_map, points\n</code></pre>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.generate_points","title":"<code>generate_points(pdf, total_points, min_x, max_x, center, radius, bias_subspace_x, space_prob, density_dif)</code>","text":"<p>Generates random (x, y) points using the accept/reject method based on a given distribution.</p>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.generate_points--parameters","title":"Parameters:","text":"<p>pdf : callable     Probability density function to sample from. total_points : int     Number of points to generate. min_x : float     Minimum x value for sampling. max_x : float     Maximum x value for sampling. center : np.ndarray     Coordinates of the center of the top-hat distribution. radius : float     Radius of the top-hat region. bias_subspace_x : float     Probability at the top of the top-hat. space_prob : float     Probability outside the top-hat region. density_dif : float     Scaling factor for density differences.</p>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.generate_points--returns","title":"Returns:","text":"<p>np.ndarray     Array of generated points.</p> Source code in <code>SMS_BP/simulate_foci.py</code> <pre><code>def generate_points(\n    pdf: callable,\n    total_points: int,\n    min_x: float,\n    max_x: float,\n    center: np.ndarray,\n    radius: float,\n    bias_subspace_x: float,\n    space_prob: float,\n    density_dif: float,\n) -&gt; np.ndarray:\n    \"\"\"\n    Generates random (x, y) points using the accept/reject method based on a given distribution.\n\n    Parameters:\n    -----------\n    pdf : callable\n        Probability density function to sample from.\n    total_points : int\n        Number of points to generate.\n    min_x : float\n        Minimum x value for sampling.\n    max_x : float\n        Maximum x value for sampling.\n    center : np.ndarray\n        Coordinates of the center of the top-hat distribution.\n    radius : float\n        Radius of the top-hat region.\n    bias_subspace_x : float\n        Probability at the top of the top-hat.\n    space_prob : float\n        Probability outside the top-hat region.\n    density_dif : float\n        Scaling factor for density differences.\n\n    Returns:\n    --------\n    np.ndarray\n        Array of generated points.\n    \"\"\"\n    xy_coords = []\n    while len(xy_coords) &lt; total_points:\n        # generate candidate variable\n        var = np.random.uniform([min_x, min_x], [max_x, max_x])\n        # generate varibale to condition var1\n        var2 = np.random.uniform(0, 1)\n        # apply condition\n        pdf_val = pdf(var, center, radius, bias_subspace_x, space_prob)\n        if var2 &lt; ((1.0 / density_dif) * (max_x - min_x) ** 2) * pdf_val:\n            xy_coords.append(var)\n    return np.array(xy_coords)\n</code></pre>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.generate_points_from_cls","title":"<code>generate_points_from_cls(pdf, total_points, volume, bounds, density_dif)</code>","text":"<p>Generates random (x, y, z) points using the accept/reject method based on a given distribution.</p>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.generate_points_from_cls--parameters","title":"Parameters:","text":"<p>pdf : callable     Probability density function to sample from. total_points : int     Number of points to generate. bound : list with the following     min_x : float         Minimum x value for sampling.     max_x : float         Maximum x value for sampling.     min_y : float         Minimum y value for sampling.     max_y : float         Maximum y value for sampling.     min_z : float         Minimum z value for sampling.     max_z : float         Maximum z value for sampling. volume : float,     volume of region sampling density_dif : float     Scaling factor for density differences.</p>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.generate_points_from_cls--returns","title":"Returns:","text":"<p>np.ndarray     Array of generated (x, y, z) points.</p> Source code in <code>SMS_BP/simulate_foci.py</code> <pre><code>def generate_points_from_cls(\n    pdf: Callable,\n    total_points: int,\n    volume: float,\n    bounds: Tuple[float, float, float, float, float, float],\n    density_dif: float,\n) -&gt; np.ndarray:\n    \"\"\"\n    Generates random (x, y, z) points using the accept/reject method based on a given distribution.\n\n    Parameters:\n    -----------\n    pdf : callable\n        Probability density function to sample from.\n    total_points : int\n        Number of points to generate.\n    bound : list with the following\n        min_x : float\n            Minimum x value for sampling.\n        max_x : float\n            Maximum x value for sampling.\n        min_y : float\n            Minimum y value for sampling.\n        max_y : float\n            Maximum y value for sampling.\n        min_z : float\n            Minimum z value for sampling.\n        max_z : float\n            Maximum z value for sampling.\n    volume : float,\n        volume of region sampling\n    density_dif : float\n        Scaling factor for density differences.\n\n    Returns:\n    --------\n    np.ndarray\n        Array of generated (x, y, z) points.\n    \"\"\"\n    min_x, max_x, min_y, max_y, min_z, max_z = bounds\n    xyz_coords = []\n    while len(xyz_coords) &lt; total_points:\n        # generate candidate variable\n        var = np.random.uniform([min_x, min_y, min_z], [max_x, max_y, max_z])\n        # generate varibale to condition var1\n        var2 = np.random.uniform(0, 1)\n        # apply condition\n        pdf_val = pdf(var)\n        if var2 &lt; ((1.0 / density_dif) * volume) * pdf_val:\n            xyz_coords.append(var)\n    return np.array(xyz_coords)\n</code></pre>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.generate_radial_points","title":"<code>generate_radial_points(total_points, center, radius)</code>","text":"<p>Generates uniformly distributed points in a circle of a given radius.</p>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.generate_radial_points--parameters","title":"Parameters:","text":"<p>total_points : int     Number of points to generate. center : np.ndarray     Coordinates of the center of the circle. radius : float     Radius of the circle.</p>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.generate_radial_points--returns","title":"Returns:","text":"<p>np.ndarray     Array of generated (x, y) coordinates.</p> Source code in <code>SMS_BP/simulate_foci.py</code> <pre><code>def generate_radial_points(\n    total_points: int, center: np.ndarray, radius: float\n) -&gt; np.ndarray:\n    \"\"\"\n    Generates uniformly distributed points in a circle of a given radius.\n\n    Parameters:\n    -----------\n    total_points : int\n        Number of points to generate.\n    center : np.ndarray\n        Coordinates of the center of the circle.\n    radius : float\n        Radius of the circle.\n\n    Returns:\n    --------\n    np.ndarray\n        Array of generated (x, y) coordinates.\n    \"\"\"\n    theta = 2.0 * np.pi * np.random.random(size=total_points)\n    rad = radius * np.sqrt(np.random.random(size=total_points))\n    x = rad * np.cos(theta) + center[0]\n    y = rad * np.sin(theta) + center[1]\n    return np.stack((x, y), axis=-1)\n</code></pre>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.generate_sphere_points","title":"<code>generate_sphere_points(total_points, center, radius)</code>","text":"<p>Generates uniformly distributed points in a sphere of a given radius.</p>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.generate_sphere_points--parameters","title":"Parameters:","text":"<p>total_points : int     Number of points to generate. center : np.ndarray     Coordinates of the center of the sphere. radius : float     Radius of the sphere.</p>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.generate_sphere_points--returns","title":"Returns:","text":"<p>np.ndarray     Array of generated (x, y, z) coordinates.</p> Source code in <code>SMS_BP/simulate_foci.py</code> <pre><code>def generate_sphere_points(\n    total_points: int, center: np.ndarray, radius: float\n) -&gt; np.ndarray:\n    \"\"\"\n    Generates uniformly distributed points in a sphere of a given radius.\n\n    Parameters:\n    -----------\n    total_points : int\n        Number of points to generate.\n    center : np.ndarray\n        Coordinates of the center of the sphere.\n    radius : float\n        Radius of the sphere.\n\n    Returns:\n    --------\n    np.ndarray\n        Array of generated (x, y, z) coordinates.\n    \"\"\"\n    # check to see if the center is an array of size 3\n    if len(center) != 3:\n        # make it an array of size 3 with the last element being 0\n        center = np.array([center[0], center[1], 0])\n\n    theta = 2.0 * np.pi * np.random.random(size=total_points)\n    phi = np.arccos(2.0 * np.random.random(size=total_points) - 1.0)\n    rad = radius * np.cbrt(np.random.random(size=total_points))\n    x = rad * np.cos(theta) * np.sin(phi) + center[0]\n    y = rad * np.sin(theta) * np.sin(phi) + center[1]\n    z = rad * np.cos(phi) + center[2]\n    return np.stack((x, y, z), axis=-1)\n</code></pre>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.get_gaussian","title":"<code>get_gaussian(mu, sigma, domain=[list(range(10)), list(range(10))])</code>","text":"<p>Generates a 2D Gaussian distribution over a given domain.</p>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.get_gaussian--parameters","title":"Parameters:","text":"<p>mu : np.ndarray     Center position of the Gaussian (x, y). sigma : float | np.ndarray     Standard deviation(s) of the Gaussian. domain : list[list[int]], optional     Domain over which to compute the Gaussian (default is 0-9 for x and y).</p>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.get_gaussian--returns","title":"Returns:","text":"<p>np.ndarray     2D array representing the Gaussian distribution over the domain.</p> Source code in <code>SMS_BP/simulate_foci.py</code> <pre><code>def get_gaussian(\n    mu: np.ndarray,\n    sigma: float | np.ndarray,\n    domain: list[list[int]] = [list(range(10)), list(range(10))],\n) -&gt; np.ndarray:\n    \"\"\"\n    Generates a 2D Gaussian distribution over a given domain.\n\n    Parameters:\n    -----------\n    mu : np.ndarray\n        Center position of the Gaussian (x, y).\n    sigma : float | np.ndarray\n        Standard deviation(s) of the Gaussian.\n    domain : list[list[int]], optional\n        Domain over which to compute the Gaussian (default is 0-9 for x and y).\n\n    Returns:\n    --------\n    np.ndarray\n        2D array representing the Gaussian distribution over the domain.\n    \"\"\"\n    # generate a multivariate normal distribution with the given mu and sigma over the domain using scipy stats\n    # generate the grid\n    x = domain[0]\n    y = domain[1]\n    xx, yy = np.meshgrid(x, y)\n    # generate the multivariate normal distribution\n    rv = multivariate_normal(mu, sigma)\n    # generate the probability distribution\n    gauss = rv.pdf(np.dstack((xx, yy)))\n    # reshape the distribution on the grid\n    return gauss\n</code></pre>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.get_lengths","title":"<code>get_lengths(track_distribution, track_length_mean, total_tracks)</code>","text":"<p>Returns track lengths based on the specified distribution.</p>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.get_lengths--parameters","title":"Parameters:","text":"<p>track_distribution : str     The distribution of track lengths. Options are \"exponential\", \"uniform\", and \"constant\". track_length_mean : int     The mean length of the tracks. total_tracks : int     The total number of tracks to generate.</p>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.get_lengths--returns","title":"Returns:","text":"<p>np.ndarray     An array of track lengths (shape: (total_tracks,)).</p>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.get_lengths--raises","title":"Raises:","text":"<p>ValueError     If the distribution type is not recognized.</p> Source code in <code>SMS_BP/simulate_foci.py</code> <pre><code>def get_lengths(\n    track_distribution: str, track_length_mean: int, total_tracks: int\n) -&gt; np.ndarray:\n    \"\"\"\n    Returns track lengths based on the specified distribution.\n\n    Parameters:\n    -----------\n    track_distribution : str\n        The distribution of track lengths. Options are \"exponential\", \"uniform\", and \"constant\".\n    track_length_mean : int\n        The mean length of the tracks.\n    total_tracks : int\n        The total number of tracks to generate.\n\n    Returns:\n    --------\n    np.ndarray\n        An array of track lengths (shape: (total_tracks,)).\n\n    Raises:\n    -------\n    ValueError\n        If the distribution type is not recognized.\n    \"\"\"\n    if track_distribution == \"exponential\":\n        # make sure each of the lengths is an integer and is greater than or equal to 1\n        return np.array(\n            np.ceil(np.random.exponential(scale=track_length_mean, size=total_tracks)),\n            dtype=int,\n        )\n    elif track_distribution == \"uniform\":\n        # make sure each of the lengths is an integer\n        return np.array(\n            np.ceil(\n                np.random.uniform(\n                    low=1, high=2 * (track_length_mean) - 1, size=total_tracks\n                )\n            ),\n            dtype=int,\n        )\n    elif track_distribution == \"constant\":\n        return np.array(np.ones(total_tracks) * int(track_length_mean), dtype=int)\n    else:\n        raise ValueError(\"Distribution not recognized\")\n</code></pre>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.radius_spherical_cap","title":"<code>radius_spherical_cap(R, center, z_slice)</code>","text":"<p>Calculates the radius of a spherical cap at a given z-slice.</p>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.radius_spherical_cap--parameters","title":"Parameters:","text":"<p>R : float     Radius of the sphere. center : np.ndarray     [x, y, z] coordinates of the center of the sphere. z_slice : float     Z-coordinate of the slice relative to the sphere's center.</p>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.radius_spherical_cap--returns","title":"Returns:","text":"<p>float     Radius of the spherical cap at the given z-slice.</p>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.radius_spherical_cap--raises","title":"Raises:","text":"<p>ValueError     If the z-slice is outside the sphere.</p> Source code in <code>SMS_BP/simulate_foci.py</code> <pre><code>def radius_spherical_cap(R: float, center: np.ndarray, z_slice: float) -&gt; float:\n    \"\"\"\n    Calculates the radius of a spherical cap at a given z-slice.\n\n    Parameters:\n    -----------\n    R : float\n        Radius of the sphere.\n    center : np.ndarray\n        [x, y, z] coordinates of the center of the sphere.\n    z_slice : float\n        Z-coordinate of the slice relative to the sphere's center.\n\n    Returns:\n    --------\n    float\n        Radius of the spherical cap at the given z-slice.\n\n    Raises:\n    -------\n    ValueError\n        If the z-slice is outside the sphere.\n    \"\"\"\n    # check if z_slice is within the sphere\n    if z_slice &gt; R:\n        raise ValueError(\"z_slice is outside the sphere\")\n    # check if z_slice is at the edge of the sphere\n    if z_slice == R:\n        return 0\n    # check if z_slice is at the center of the sphere\n    if z_slice == 0:\n        return R\n    # calculate the radius of the spherical cap\n    return np.sqrt(R**2 - (z_slice) ** 2)\n</code></pre>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.tophat_function_2d","title":"<code>tophat_function_2d(var, center, radius, bias_subspace, space_prob, **kwargs)</code>","text":"<p>Defines a circular top-hat probability distribution in 2D.</p>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.tophat_function_2d--parameters","title":"Parameters:","text":"<p>var : np.ndarray     [x, y] coordinates for sampling the distribution. center : np.ndarray     [c1, c2] coordinates representing the center of the top-hat region. radius : float     Radius of the circular top-hat. bias_subspace : float     Probability at the center of the top-hat. space_prob : float     Probability outside the top-hat region.</p>"},{"location":"simulate_foci_reference/#SMS_BP.simulate_foci.tophat_function_2d--returns","title":"Returns:","text":"<p>float     The probability value at the given coordinates.</p> Source code in <code>SMS_BP/simulate_foci.py</code> <pre><code>def tophat_function_2d(\n    var: np.ndarray,\n    center: np.ndarray,\n    radius: float,\n    bias_subspace: float,\n    space_prob: float,\n    **kwargs,\n) -&gt; float:\n    \"\"\"\n    Defines a circular top-hat probability distribution in 2D.\n\n    Parameters:\n    -----------\n    var : np.ndarray\n        [x, y] coordinates for sampling the distribution.\n    center : np.ndarray\n        [c1, c2] coordinates representing the center of the top-hat region.\n    radius : float\n        Radius of the circular top-hat.\n    bias_subspace : float\n        Probability at the center of the top-hat.\n    space_prob : float\n        Probability outside the top-hat region.\n\n    Returns:\n    --------\n    float\n        The probability value at the given coordinates.\n    \"\"\"\n    x = var[0]\n    y = var[1]\n    if ((x - center[0]) ** 2 + (y - center[1]) ** 2) &lt;= radius**2:\n        return bias_subspace\n    else:\n        return space_prob\n</code></pre>"},{"location":"cells/budding_yeast_cell/","title":"Budding Yeast Cell","text":""},{"location":"cells/budding_yeast_cell/#budding_yeast_cell_reference","title":"Budding Yeast Cell Reference","text":""},{"location":"cells/budding_yeast_cell/#SMS_BP.cells.budding_yeast_cell.BuddingCell","title":"<code>BuddingCell</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseCell</code></p> <p>Represents a budding yeast cell composed of two connected ovoids (mother and bud). The cells are connected at a \"neck\" region, with the bud growing from the mother cell.</p> <p>Attributes:</p> Name Type Description <code>center</code> <code>ndarray</code> <p>The (x, y, z) coordinates of the mother cell's center in XYZ plane</p> <code>mother_radius_x</code> <code>float</code> <p>Mother cell radius along X axis</p> <code>mother_radius_y</code> <code>float</code> <p>Mother cell radius along Y axis</p> <code>mother_radius_z</code> <code>float</code> <p>Mother cell radius along Z axis</p> <code>bud_radius_x</code> <code>float</code> <p>Bud radius along X axis</p> <code>bud_radius_y</code> <code>float</code> <p>Bud radius along Y axis</p> <code>bud_radius_z</code> <code>float</code> <p>Bud radius along Z axis</p> <code>bud_angle</code> <code>float</code> <p>Angle in radians from x-axis where bud emerges</p> <code>bud_distance</code> <code>float</code> <p>Distance between mother and bud centers</p> <code>neck_radius</code> <code>float</code> <p>Radius of the connecting neck region</p> Source code in <code>SMS_BP/cells/budding_yeast_cell.py</code> <pre><code>@dataclass\nclass BuddingCell(BaseCell):\n    \"\"\"\n    Represents a budding yeast cell composed of two connected ovoids (mother and bud).\n    The cells are connected at a \"neck\" region, with the bud growing from the mother cell.\n\n    Attributes:\n        center (np.ndarray): The (x, y, z) coordinates of the mother cell's center in XYZ plane\n        mother_radius_x (float): Mother cell radius along X axis\n        mother_radius_y (float): Mother cell radius along Y axis\n        mother_radius_z (float): Mother cell radius along Z axis\n        bud_radius_x (float): Bud radius along X axis\n        bud_radius_y (float): Bud radius along Y axis\n        bud_radius_z (float): Bud radius along Z axis\n        bud_angle (float): Angle in radians from x-axis where bud emerges\n        bud_distance (float): Distance between mother and bud centers\n        neck_radius (float): Radius of the connecting neck region\n    \"\"\"\n\n    center: np.ndarray | List[float] | Tuple\n    mother_radius_x: float\n    mother_radius_y: float\n    mother_radius_z: float\n    bud_radius_x: float\n    bud_radius_y: float\n    bud_radius_z: float\n    bud_angle: float\n    bud_distance: float\n    neck_radius: float\n\n    def contains_point_fallback(\n        self, x: float, y: float, z: float, tolerance: float = 1e-3\n    ) -&gt; bool:\n        \"\"\"\n        Determines if a given point is inside the BuddingCell.\n        A point is inside if it's within the mother cell, the bud, or the neck region.\n\n        Args:\n            point (np.ndarray | List[float] | Tuple): The (x, y, z) coordinates of the point to check\n\n        Returns:\n            bool: True if the point is inside the cell, False otherwise\n        \"\"\"\n        # Ensure point is a numpy array for vector operations\n        point = np.array([x, y, z])\n        mother_center = np.array(self.center)\n\n        # Calculate bud center based on angle and distance\n        bud_x = mother_center[0] + self.bud_distance * np.cos(self.bud_angle)\n        bud_y = mother_center[1] + self.bud_distance * np.sin(self.bud_angle)\n        bud_center = np.array([bud_x, bud_y, mother_center[2]])\n\n        # Check if point is inside the mother cell (scaled ellipsoid)\n        x, y, z = point - mother_center\n        mother_distance_squared = (\n            (x / self.mother_radius_x) ** 2\n            + (y / self.mother_radius_y) ** 2\n            + (z / self.mother_radius_z) ** 2\n        )\n        if mother_distance_squared &lt;= 1:\n            return True\n\n        # Check if point is inside the bud (scaled ellipsoid)\n        x, y, z = point - bud_center\n        bud_distance_squared = (\n            (x / self.bud_radius_x) ** 2\n            + (y / self.bud_radius_y) ** 2\n            + (z / self.bud_radius_z) ** 2\n        )\n        if bud_distance_squared &lt;= 1:\n            return True\n\n        # Check if point is inside the neck region\n        # First, project the point onto the line between mother and bud centers\n        mother_to_bud_vec = bud_center - mother_center\n        mother_to_bud_length = np.linalg.norm(mother_to_bud_vec)\n        mother_to_bud_unit = mother_to_bud_vec / mother_to_bud_length\n\n        mother_to_point_vec = point - mother_center\n        projection_length = np.dot(mother_to_point_vec, mother_to_bud_unit)\n\n        # Calculate minimum distance from point to the center line\n        if 0 &lt;= projection_length &lt;= mother_to_bud_length:\n            projection_point = mother_center + projection_length * mother_to_bud_unit\n            distance_to_line = np.linalg.norm(point - projection_point)\n\n            # The neck is modeled as a truncated cone\n            # Interpolate the radius at this point along the neck\n            if projection_length &lt;= self.mother_radius_x:\n                # Within mother cell radius from the center\n                local_radius = self.neck_radius\n            elif projection_length &gt;= mother_to_bud_length - self.bud_radius_x:\n                # Within bud cell radius from the bud center\n                local_radius = self.neck_radius\n            else:\n                local_radius = self.neck_radius\n\n            return distance_to_line &lt;= local_radius\n\n        return False\n</code></pre>"},{"location":"cells/budding_yeast_cell/#SMS_BP.cells.budding_yeast_cell.BuddingCell.contains_point_fallback","title":"<code>contains_point_fallback(x, y, z, tolerance=0.001)</code>","text":"<p>Determines if a given point is inside the BuddingCell. A point is inside if it's within the mother cell, the bud, or the neck region.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>ndarray | List[float] | Tuple</code> <p>The (x, y, z) coordinates of the point to check</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the point is inside the cell, False otherwise</p> Source code in <code>SMS_BP/cells/budding_yeast_cell.py</code> <pre><code>def contains_point_fallback(\n    self, x: float, y: float, z: float, tolerance: float = 1e-3\n) -&gt; bool:\n    \"\"\"\n    Determines if a given point is inside the BuddingCell.\n    A point is inside if it's within the mother cell, the bud, or the neck region.\n\n    Args:\n        point (np.ndarray | List[float] | Tuple): The (x, y, z) coordinates of the point to check\n\n    Returns:\n        bool: True if the point is inside the cell, False otherwise\n    \"\"\"\n    # Ensure point is a numpy array for vector operations\n    point = np.array([x, y, z])\n    mother_center = np.array(self.center)\n\n    # Calculate bud center based on angle and distance\n    bud_x = mother_center[0] + self.bud_distance * np.cos(self.bud_angle)\n    bud_y = mother_center[1] + self.bud_distance * np.sin(self.bud_angle)\n    bud_center = np.array([bud_x, bud_y, mother_center[2]])\n\n    # Check if point is inside the mother cell (scaled ellipsoid)\n    x, y, z = point - mother_center\n    mother_distance_squared = (\n        (x / self.mother_radius_x) ** 2\n        + (y / self.mother_radius_y) ** 2\n        + (z / self.mother_radius_z) ** 2\n    )\n    if mother_distance_squared &lt;= 1:\n        return True\n\n    # Check if point is inside the bud (scaled ellipsoid)\n    x, y, z = point - bud_center\n    bud_distance_squared = (\n        (x / self.bud_radius_x) ** 2\n        + (y / self.bud_radius_y) ** 2\n        + (z / self.bud_radius_z) ** 2\n    )\n    if bud_distance_squared &lt;= 1:\n        return True\n\n    # Check if point is inside the neck region\n    # First, project the point onto the line between mother and bud centers\n    mother_to_bud_vec = bud_center - mother_center\n    mother_to_bud_length = np.linalg.norm(mother_to_bud_vec)\n    mother_to_bud_unit = mother_to_bud_vec / mother_to_bud_length\n\n    mother_to_point_vec = point - mother_center\n    projection_length = np.dot(mother_to_point_vec, mother_to_bud_unit)\n\n    # Calculate minimum distance from point to the center line\n    if 0 &lt;= projection_length &lt;= mother_to_bud_length:\n        projection_point = mother_center + projection_length * mother_to_bud_unit\n        distance_to_line = np.linalg.norm(point - projection_point)\n\n        # The neck is modeled as a truncated cone\n        # Interpolate the radius at this point along the neck\n        if projection_length &lt;= self.mother_radius_x:\n            # Within mother cell radius from the center\n            local_radius = self.neck_radius\n        elif projection_length &gt;= mother_to_bud_length - self.bud_radius_x:\n            # Within bud cell radius from the bud center\n            local_radius = self.neck_radius\n        else:\n            local_radius = self.neck_radius\n\n        return distance_to_line &lt;= local_radius\n\n    return False\n</code></pre>"},{"location":"cells/budding_yeast_cell/#SMS_BP.cells.budding_yeast_cell.make_BuddingCell","title":"<code>make_BuddingCell(center, mother_radius_x, mother_radius_y, mother_radius_z, bud_radius_x, bud_radius_y, bud_radius_z, bud_angle, bud_distance, neck_radius)</code>","text":"<p>Create a budding yeast cell using PyVista meshes.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>ndarray | List[float] | Tuple</code> <p>Center point of the mother cell</p> required <code>mother_radius_x/y/z</code> <p>Radii of the mother cell along each axis</p> required <code>bud_radius_x/y/z</code> <p>Radii of the bud cell along each axis</p> required <code>bud_angle</code> <code>float</code> <p>Angle in radians from x-axis where bud emerges</p> required <code>bud_distance</code> <code>float</code> <p>Distance between mother and bud centers</p> required <code>neck_radius</code> <code>float</code> <p>Radius of the connecting neck region</p> required <p>Returns:</p> Name Type Description <code>BuddingCell</code> <code>BuddingCell</code> <p>Instance with PyVista mesh</p> Source code in <code>SMS_BP/cells/budding_yeast_cell.py</code> <pre><code>def make_BuddingCell(\n    center: np.ndarray | List[float] | Tuple,\n    mother_radius_x: float,\n    mother_radius_y: float,\n    mother_radius_z: float,\n    bud_radius_x: float,\n    bud_radius_y: float,\n    bud_radius_z: float,\n    bud_angle: float,\n    bud_distance: float,\n    neck_radius: float,\n) -&gt; BuddingCell:\n    \"\"\"\n    Create a budding yeast cell using PyVista meshes.\n\n    Args:\n        center: Center point of the mother cell\n        mother_radius_x/y/z: Radii of the mother cell along each axis\n        bud_radius_x/y/z: Radii of the bud cell along each axis\n        bud_angle: Angle in radians from x-axis where bud emerges\n        bud_distance: Distance between mother and bud centers\n        neck_radius: Radius of the connecting neck region\n\n    Returns:\n        BuddingCell: Instance with PyVista mesh\n    \"\"\"\n    # Validate inputs\n    center = np.array(center)\n    if center.shape != (3,):\n        raise ValueError(\"Center must be a 3D point\")\n\n    # Calculate bud center\n    bud_center = np.array(\n        [\n            center[0] + bud_distance * np.cos(bud_angle),\n            center[1] + bud_distance * np.sin(bud_angle),\n            center[2],\n        ]\n    )\n\n    # Create mother cell ellipsoid\n    mother = pv.ParametricEllipsoid(\n        xradius=mother_radius_x,\n        yradius=mother_radius_y,\n        zradius=mother_radius_z,\n        center=center,\n    )\n\n    # Create bud cell ellipsoid\n    bud = pv.ParametricEllipsoid(\n        xradius=bud_radius_x,\n        yradius=bud_radius_y,\n        zradius=bud_radius_z,\n        center=bud_center,\n    )\n\n    # Create neck region (cylinder)\n    # Calculate direction vector from mother to bud\n    direction = bud_center - center\n    direction = direction / np.linalg.norm(direction)\n\n    # Create cylinder for neck\n    cylinder = pv.Cylinder(\n        center=(center + bud_center) / 2,  # Midpoint\n        direction=direction,\n        radius=neck_radius,\n        height=bud_distance,\n    )\n\n    # Combine shapes using boolean operations\n    # First combine mother and neck\n    mother_and_neck = mother.boolean_union(cylinder)\n\n    # Then add the bud\n    complete_cell = mother_and_neck.boolean_union(bud)\n\n    # Clean up the mesh\n    complete_cell = complete_cell.clean()\n    complete_cell = complete_cell.fill_holes(1)\n\n    # Verify mesh integrity\n    edges = complete_cell.extract_feature_edges(\n        feature_edges=False, manifold_edges=False\n    )\n    assert edges.n_cells == 0, \"Mesh has non-manifold edges\"\n\n    return BuddingCell(\n        mesh=complete_cell,\n        center=center,\n        mother_radius_x=mother_radius_x,\n        mother_radius_y=mother_radius_y,\n        mother_radius_z=mother_radius_z,\n        bud_radius_x=bud_radius_x,\n        bud_radius_y=bud_radius_y,\n        bud_radius_z=bud_radius_z,\n        bud_angle=bud_angle,\n        bud_distance=bud_distance,\n        neck_radius=neck_radius,\n    )\n</code></pre>"},{"location":"cells/cell_factory/","title":"Cell Factory","text":""},{"location":"cells/cell_factory/#cell_factory_reference","title":"Cell Factory Reference","text":""},{"location":"cells/cell_factory/#SMS_BP.cells.cell_factory.create_cell","title":"<code>create_cell(cell_type, params)</code>","text":"<p>Create a validated cell instance.</p> <p>Parameters:</p> Name Type Description Default <code>cell_type</code> <code>Union[str, CellType]</code> <p>Cell type (string or enum)</p> required <code>params</code> <code>Dict[str, Any]</code> <p>Dictionary of cell parameters.</p> required <p>Returns:</p> Type Description <code>BaseCell</code> <p>BaseCell instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If validation fails.</p> Source code in <code>SMS_BP/cells/cell_factory.py</code> <pre><code>def create_cell(cell_type: Union[str, CellType], params: Dict[str, Any]) -&gt; BaseCell:\n    \"\"\"\n    Create a validated cell instance.\n\n    Args:\n        cell_type: Cell type (string or enum)\n        params: Dictionary of cell parameters.\n\n    Returns:\n        BaseCell instance.\n\n    Raises:\n        ValueError: If validation fails.\n    \"\"\"\n    if isinstance(cell_type, str):\n        try:\n            cell_type = CellType(cell_type)\n        except ValueError:\n            raise ValueError(f\"Unknown cell type: {cell_type}\")\n\n    if cell_type not in _CELL_CREATION_MAP:\n        raise ValueError(f\"Unknown cell type: {cell_type}\")\n\n    is_valid, errors = validate_cell_parameters(cell_type, params)\n    if not is_valid:\n        raise ValueError(f\"Invalid {cell_type} configuration: {'; '.join(errors)}\")\n\n    func, param_keys = _CELL_CREATION_MAP[cell_type]\n    return func(**{key: params[key] for key in param_keys})\n</code></pre>"},{"location":"cells/cell_factory/#SMS_BP.cells.cell_factory.validate_cell_parameters","title":"<code>validate_cell_parameters(cell_type, params)</code>","text":"<p>Validate parameters for a given cell type.</p> <p>Parameters:</p> Name Type Description Default <code>cell_type</code> <code>Union[str, CellType]</code> <p>The cell type (string or enum)</p> required <code>params</code> <code>Dict[str, Any]</code> <p>Dictionary of parameters</p> required <p>Returns:</p> Type Description <code>Tuple[bool, List[str]]</code> <p>Tuple of (is_valid, error_messages)</p> Source code in <code>SMS_BP/cells/cell_factory.py</code> <pre><code>def validate_cell_parameters(\n    cell_type: Union[str, CellType], params: Dict[str, Any]\n) -&gt; Tuple[bool, List[str]]:\n    \"\"\"\n    Validate parameters for a given cell type.\n\n    Args:\n        cell_type: The cell type (string or enum)\n        params: Dictionary of parameters\n\n    Returns:\n        Tuple of (is_valid, error_messages)\n    \"\"\"\n    if isinstance(cell_type, str):\n        try:\n            cell_type = CellType(cell_type)\n        except ValueError:\n            return False, [f\"Unknown cell type: {cell_type}\"]\n\n    if cell_type not in _CELL_PARAM_CLASSES:\n        return False, [f\"Unknown cell type: {cell_type}\"]\n\n    return _validate_parameters(cell_type, params)\n</code></pre>"},{"location":"utils/decorators_reference/","title":"Decorators","text":""},{"location":"utils/decorators_reference/#decorators_reference","title":"Decorators Reference","text":""},{"location":"utils/decorators_reference/#SMS_BP.utils.decorators.CountCalls","title":"<code>CountCalls</code>","text":"<p>Count how many times a function is called</p> Source code in <code>SMS_BP/utils/decorators.py</code> <pre><code>class CountCalls:\n    \"\"\"\n    Count how many times a function is called\n    \"\"\"\n\n    def __init__(self, func):\n        functools.update_wrapper(self, func)\n        self.func = func\n        self.num_calls = 0\n\n    def __call__(self, *args, **kwargs):\n        self.num_calls += 1\n        print(f\"Call {self.num_calls} of {self.func.__name__!r}\")\n        return self.func(*args, **kwargs)\n</code></pre>"},{"location":"utils/decorators_reference/#SMS_BP.utils.decorators.cache","title":"<code>cache(func)</code>","text":"<p>Keep a cache of previous function calls</p> Source code in <code>SMS_BP/utils/decorators.py</code> <pre><code>def cache(func):\n    \"\"\"Keep a cache of previous function calls\"\"\"\n\n    @functools.wraps(func)\n    def wrapper_cache(*args, **kwargs):\n        cache_key = args + tuple(kwargs.items())\n        if not hasattr(wrapper_cache, \"cache\"):\n            wrapper_cache.cache = {}\n        if cache_key not in wrapper_cache.cache:\n            wrapper_cache.cache[cache_key] = func(*args, **kwargs)\n        return wrapper_cache.cache[cache_key]\n\n    wrapper_cache.cache = dict()\n    return wrapper_cache\n</code></pre>"},{"location":"utils/decorators_reference/#SMS_BP.utils.decorators.debug","title":"<code>debug(func)</code>","text":"<p>Print the function signature and return value</p> Source code in <code>SMS_BP/utils/decorators.py</code> <pre><code>def debug(func):\n    \"\"\"\n    Print the function signature and return value\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper_debug(*args, **kwargs):\n        args_repr = [repr(a) for a in args]  # 1\n        kwargs_repr = [f\"{k}={v!r}\" for k, v in kwargs.items()]  # 2\n        signature = \", \".join(args_repr + kwargs_repr)  # 3\n        print(f\"Calling {func.__name__}({signature})\")\n        value = func(*args, **kwargs)\n        print(f\"{func.__name__!r} returned {value!r}\")  # 4\n        return value\n\n    return wrapper_debug\n</code></pre>"},{"location":"utils/decorators_reference/#SMS_BP.utils.decorators.deprecated","title":"<code>deprecated(reason)</code>","text":"<p>This is a decorator which can be used to mark functions as deprecated. It will result in a warning being emitted when the function is used.</p> Source code in <code>SMS_BP/utils/decorators.py</code> <pre><code>def deprecated(reason):\n    \"\"\"\n    This is a decorator which can be used to mark functions\n    as deprecated. It will result in a warning being emitted\n    when the function is used.\n    \"\"\"\n\n    if isinstance(reason, string_types):\n        # The @deprecated is used with a 'reason'.\n        #\n        # .. code-block:: python\n        #\n        #    @deprecated(\"please, use another function\")\n        #    def old_function(x, y):\n        #      pass\n\n        def decorator(func1):\n            if inspect.isclass(func1):\n                fmt1 = \"Call to deprecated class {name} ({reason}).\"\n            else:\n                fmt1 = \"Call to deprecated function {name} ({reason}).\"\n\n            @functools.wraps(func1)\n            def new_func1(*args, **kwargs):\n                warnings.simplefilter(\"always\", DeprecationWarning)\n                warnings.warn(\n                    fmt1.format(name=func1.__name__, reason=reason),\n                    category=DeprecationWarning,\n                    stacklevel=2,\n                )\n                warnings.simplefilter(\"default\", DeprecationWarning)\n                return func1(*args, **kwargs)\n\n            return new_func1\n\n        return decorator\n\n    elif inspect.isclass(reason) or inspect.isfunction(reason):\n        # The @deprecated is used without any 'reason'.\n        #\n        # .. code-block:: python\n        #\n        #    @deprecated\n        #    def old_function(x, y):\n        #      pass\n\n        func2 = reason\n\n        if inspect.isclass(func2):\n            fmt2 = \"Call to deprecated class {name}.\"\n        else:\n            fmt2 = \"Call to deprecated function {name}.\"\n\n        @functools.wraps(func2)\n        def new_func2(*args, **kwargs):\n            warnings.simplefilter(\"always\", DeprecationWarning)\n            warnings.warn(\n                fmt2.format(name=func2.__name__),\n                category=DeprecationWarning,\n                stacklevel=2,\n            )\n            warnings.simplefilter(\"default\", DeprecationWarning)\n            return func2(*args, **kwargs)\n\n        return new_func2\n\n    else:\n        raise TypeError(repr(type(reason)))\n</code></pre>"},{"location":"utils/decorators_reference/#SMS_BP.utils.decorators.repeat","title":"<code>repeat(_func=None, *, num_times=2)</code>","text":"<p>Repeat the function a number of times</p>"},{"location":"utils/decorators_reference/#SMS_BP.utils.decorators.repeat--parameters","title":"Parameters:","text":"<p>num_times : int     number of times to repeat the function</p>"},{"location":"utils/decorators_reference/#SMS_BP.utils.decorators.repeat--returns","title":"Returns:","text":"<p>decorator_repeat : function     decorator function</p> Source code in <code>SMS_BP/utils/decorators.py</code> <pre><code>def repeat(_func=None, *, num_times=2):\n    \"\"\"\n    Repeat the function a number of times\n\n    Parameters:\n    -----------\n    num_times : int\n        number of times to repeat the function\n\n    Returns:\n    --------\n    decorator_repeat : function\n        decorator function\n    \"\"\"\n\n    def decorator_repeat(func):\n        @functools.wraps(func)\n        def wrapper_repeat(*args, **kwargs):\n            for _ in range(num_times):\n                value = func(*args, **kwargs)\n            return value\n\n        return wrapper_repeat\n\n    if _func is None:\n        return decorator_repeat\n    else:\n        return decorator_repeat(_func)\n</code></pre>"},{"location":"utils/decorators_reference/#SMS_BP.utils.decorators.set_unit","title":"<code>set_unit(unit)</code>","text":"<p>Register a unit on a function</p> Source code in <code>SMS_BP/utils/decorators.py</code> <pre><code>def set_unit(unit):\n    \"\"\"Register a unit on a function\"\"\"\n\n    def decorator_set_unit(func):\n        func.unit = unit\n        return func\n\n    return decorator_set_unit\n</code></pre>"},{"location":"utils/decorators_reference/#SMS_BP.utils.decorators.singleton","title":"<code>singleton(cls)</code>","text":"<p>Make a class a Singleton class (only one instance)</p> Source code in <code>SMS_BP/utils/decorators.py</code> <pre><code>def singleton(cls):\n    \"\"\"Make a class a Singleton class (only one instance)\"\"\"\n\n    @functools.wraps(cls)\n    def wrapper_singleton(*args, **kwargs):\n        if not wrapper_singleton.instance:\n            wrapper_singleton.instance = cls(*args, **kwargs)\n        return wrapper_singleton.instance\n\n    wrapper_singleton.instance = None\n    return wrapper_singleton\n</code></pre>"},{"location":"utils/decorators_reference/#SMS_BP.utils.decorators.slow_down","title":"<code>slow_down(_func=None, *, rate=1)</code>","text":"<p>Sleep given amount of seconds before calling the function</p> Source code in <code>SMS_BP/utils/decorators.py</code> <pre><code>def slow_down(_func=None, *, rate=1):\n    \"\"\"Sleep given amount of seconds before calling the function\"\"\"\n\n    def decorator_slow_down(func):\n        @functools.wraps(func)\n        def wrapper_slow_down(*args, **kwargs):\n            time.sleep(rate)\n            return func(*args, **kwargs)\n\n        return wrapper_slow_down\n\n    if _func is None:\n        return decorator_slow_down\n    else:\n        return decorator_slow_down(_func)\n</code></pre>"},{"location":"utils/decorators_reference/#SMS_BP.utils.decorators.timer","title":"<code>timer(func)</code>","text":"<p>Print the runtime of the decorated function</p> Source code in <code>SMS_BP/utils/decorators.py</code> <pre><code>def timer(func):\n    \"\"\"\n    Print the runtime of the decorated function\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper_timer(*args, **kwargs):\n        start_time = time.perf_counter()  # 1\n        value = func(*args, **kwargs)\n        end_time = time.perf_counter()  # 2\n        run_time = end_time - start_time  # 3\n        print(f\"Finished {func.__name__!r} in {run_time:.4f} secs\")\n        return value\n\n    return wrapper_timer\n</code></pre>"},{"location":"utils/maskMaker/","title":"Mask Maker","text":""},{"location":"utils/maskMaker/#mask_maker_reference","title":"Mask Maker Reference","text":""}]}